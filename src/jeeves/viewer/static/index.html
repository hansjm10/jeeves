<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeeves Viewer</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --border-active: #58a6ff;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
            --accent-orange: #db6d28;
            --phase-design-draft: #a371f7;
            --phase-design-review: #a371f7;
            --phase-design-edit: #a371f7;
            --phase-implement: #d29922;
            --phase-code-review: #db6d28;
            --phase-code-fix: #db6d28;
            --phase-complete: #58a6ff;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
        }
        
        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 24px;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .brand-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .brand-text {
            font-size: 18px;
            font-weight: 600;
        }
        
        .header-status {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .connection-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
        }
        
        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            transition: background 0.3s;
        }
        
        .connection-dot.connected {
            background: var(--accent-green);
            box-shadow: 0 0 8px var(--accent-green);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-badge.running {
            background: rgba(63, 185, 80, 0.15);
            color: var(--accent-green);
            border: 1px solid var(--accent-green);
        }
        
        .status-badge.complete {
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent-blue);
            border: 1px solid var(--accent-blue);
        }
        
        .status-badge.idle {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        /* Main Layout */
        .main {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
            min-height: calc(100vh - 60px);
        }
        
        @media (max-width: 1000px) {
            .main {
                grid-template-columns: 1fr;
            }
        }
        
        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .card-header {
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }
        
        .card-body {
            padding: 16px;
        }
        
        /* Phase Timeline */
        .phase-timeline {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .phase-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            position: relative;
        }
        
        .phase-item:not(:last-child)::after {
            content: '';
            position: absolute;
            left: 11px;
            top: 36px;
            bottom: -12px;
            width: 2px;
            background: var(--border-color);
        }
        
        .phase-item.active::after {
            background: var(--accent-blue);
        }
        
        .phase-item.complete::after {
            background: var(--accent-green);
        }
        
        .phase-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .phase-item.complete .phase-dot {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }
        
        .phase-item.active .phase-dot {
            border-color: var(--accent-blue);
            background: var(--accent-blue);
            color: white;
            animation: phase-pulse 1.5s infinite;
        }
        
        @keyframes phase-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(88, 166, 255, 0); }
        }
        
        .phase-content {
            flex: 1;
            min-width: 0;
        }
        
        .phase-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .phase-item.active .phase-name,
        .phase-item.complete .phase-name {
            color: var(--text-primary);
        }
        
        .phase-desc {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        /* Info Grid */
        .info-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        
        .info-label {
            color: var(--text-secondary);
        }
        
        .info-value {
            font-weight: 500;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }
        
        .info-value a {
            color: var(--accent-blue);
            text-decoration: none;
        }
        
        .info-value a:hover {
            text-decoration: underline;
        }
        
        /* Progress Bar */
        .progress-section {
            margin-top: 16px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .progress-bar {
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-blue));
            border-radius: 4px;
            transition: width 0.5s ease-out;
        }
        
        /* Status Checks */
        .status-checks {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .status-check {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid transparent;
            border-radius: 8px;
            font-size: 12px;
        }

        button.status-check {
            appearance: none;
            color: inherit;
            text-align: left;
            width: 100%;
        }

        .status-check.toggleable {
            cursor: pointer;
        }

        .status-check.toggleable:hover {
            border-color: var(--border-active);
        }

        .status-check.toggleable:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .check-icon {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .check-icon.pass {
            background: var(--accent-green);
        }
        
        .check-icon.fail {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
        }
        
        .check-icon.pending {
            background: var(--bg-primary);
            border: 2px solid var(--accent-yellow);
        }
        
        /* Log Panel */
        .log-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: calc(100vh - 108px);
        }
        
        .log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .panel-left {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 0;
        }

        .panel-tabs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-btn {
            padding: 6px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--text-muted);
        }

        .tab-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .log-title {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .log-count {
            background: var(--bg-primary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .log-controls {
            display: flex;
            gap: 8px;
        }
        
        .log-btn {
            padding: 6px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .log-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
        }
        
        .log-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .log-body {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .log-content {
            flex: 1;
            overflow: auto;
            padding: 16px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.6;
            background: var(--bg-primary);
        }
        
        .log-content::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        .log-content::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        .log-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
            border: 2px solid var(--bg-primary);
        }
        
        .log-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Prompt Editor Panel (tab) */
        .prompt-panel {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
        }

        .prompt-toolbar {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .prompt-file {
            flex: 1;
            min-width: 260px;
        }

        .prompt-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .prompt-tab {
            padding: 4px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .prompt-tab:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
        }

        .prompt-tab.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .prompt-editor {
            flex: 1;
            min-height: 0;
            resize: none;
        }

        /* SDK Output Panel */
        .sdk-panel {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
        }

        .sdk-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .sdk-stats {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .sdk-stat {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .sdk-stat-label {
            color: var(--text-muted);
        }

        .sdk-status-success {
            color: var(--accent-green);
            font-weight: 600;
        }

        .sdk-status-error {
            color: var(--accent-red);
            font-weight: 600;
        }

        .sdk-status-pending {
            color: var(--text-muted);
        }

        /* Context bar for token usage */
        .context-bar-container {
            display: inline-block;
            width: 50px;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            vertical-align: middle;
            margin: 0 4px;
        }

        .context-bar {
            display: block;
            height: 100%;
            width: 0%;
            border-radius: 4px;
            transition: width 0.3s ease-out, background 0.3s;
        }

        .context-bar.context-low {
            background: var(--accent-green);
        }

        .context-bar.context-medium {
            background: var(--accent-yellow);
        }

        .context-bar.context-high {
            background: var(--accent-red);
        }

        .sdk-controls {
            display: flex;
            gap: 8px;
        }

        .sdk-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sdk-conversation {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 8px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
        }

        .sdk-message {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid transparent;
        }

        .sdk-message.system {
            background: rgba(163, 113, 247, 0.1);
            border-left-color: var(--accent-purple);
        }

        .sdk-message.user {
            background: rgba(88, 166, 255, 0.1);
            border-left-color: var(--accent-blue);
        }

        .sdk-message.assistant {
            background: rgba(63, 185, 80, 0.08);
            border-left-color: var(--accent-green);
        }

        .sdk-message.tool_result {
            background: rgba(219, 109, 40, 0.1);
            border-left-color: var(--accent-orange);
            font-size: 11px;
        }

        .sdk-message.result {
            background: rgba(88, 166, 255, 0.15);
            border-left-color: var(--accent-blue);
            border-width: 4px;
        }

        .sdk-message-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .sdk-message-type {
            font-weight: 600;
            text-transform: uppercase;
        }

        .sdk-message-content {
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-primary);
        }

        .sdk-tool-use {
            margin-top: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 11px;
        }

        .sdk-tool-name {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .sdk-tool-input {
            margin-top: 4px;
            color: var(--text-secondary);
            max-height: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sdk-timeline {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 8px;
        }

        .sdk-timeline-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            margin-bottom: 4px;
            background: var(--bg-secondary);
            border-radius: 6px;
        }

        .sdk-timeline-bar {
            width: 100px;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
        }

        .sdk-timeline-fill {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 3px;
        }

        .sdk-timeline-name {
            flex: 1;
            font-size: 12px;
            color: var(--text-primary);
        }

        .sdk-timeline-duration {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .log-line {
            padding: 2px 8px;
            margin: 1px 0;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .log-line:hover {
            background: rgba(255, 255, 255, 0.03);
        }
        
        .log-line.error {
            color: var(--accent-red);
            background: rgba(248, 81, 73, 0.1);
        }
        
        .log-line.warn {
            color: var(--accent-yellow);
        }
        
        .log-line.success {
            color: var(--accent-green);
        }
        
        .log-line.info {
            color: var(--accent-blue);
        }
        
        .log-line.debug {
            color: var(--text-muted);
        }
        
        .log-line.iteration {
            color: var(--accent-purple);
            font-weight: 600;
            background: rgba(163, 113, 247, 0.1);
            margin: 8px 0;
            padding: 8px 12px;
        }

        /* Codex sections */
        .log-line.section {
            color: var(--text-secondary);
            background: rgba(139, 148, 158, 0.08);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .log-line.command {
            color: var(--accent-blue);
        }

        /* Diff styling (GitHub-ish) */
        .log-line.diff-header,
        .log-line.diff-meta,
        .log-line.diff-file,
        .log-line.diff-hunk,
        .log-line.diff-add,
        .log-line.diff-del,
        .log-line.diff-context {
            white-space: pre;
            word-break: normal;
        }

        .log-line.diff-header {
            color: var(--text-secondary);
            background: rgba(139, 148, 158, 0.06);
            font-weight: 600;
            margin-top: 6px;
        }

        .log-line.diff-meta {
            color: var(--text-muted);
        }

        .log-line.diff-file {
            color: var(--accent-blue);
            font-weight: 600;
        }

        .log-line.diff-hunk {
            color: var(--accent-purple);
            background: rgba(163, 113, 247, 0.06);
        }

        .log-line.diff-add {
            color: var(--accent-green);
            background: rgba(63, 185, 80, 0.12);
        }

        .log-line.diff-del {
            color: var(--accent-red);
            background: rgba(248, 81, 73, 0.12);
        }

        .log-line.diff-context {
            color: var(--text-primary);
        }
        
        .log-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: var(--text-muted);
        }
        
        .log-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        /* Search */
        .search-container {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .search-input:focus {
            border-color: var(--accent-blue);
        }
        
        .search-input::placeholder {
            color: var(--text-muted);
        }

        /* Controls */
        .control-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
        }

        .control-label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .control-input,
        .control-textarea {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }

        .control-input:focus,
        .control-textarea:focus {
            border-color: var(--accent-blue);
        }

        .control-textarea {
            resize: vertical;
            min-height: 70px;
            font-family: inherit;
        }

        .editor-textarea {
            min-height: 240px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .control-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .control-status {
            margin-top: 10px;
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.4;
            white-space: pre-line;
        }

        /* Iteration indicator */
        .iteration-badge {
            background: var(--bg-tertiary);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .iteration-badge .number {
            font-weight: 700;
            font-size: 20px;
            color: var(--accent-purple);
        }
        
        .iteration-badge .label {
            color: var(--text-secondary);
        }
        
        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 48px 24px;
            text-align: center;
        }
        
        .empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .empty-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .empty-desc {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        /* Keyboard hint */
        .keyboard-hint {
            position: fixed;
            bottom: 16px;
            right: 16px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .keyboard-hint kbd {
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-family: inherit;
        }

        /* Workflow Graph Styles */
        .workflow-graph-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        .workflow-graph-container svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .workflow-node {
            cursor: pointer;
        }

        .workflow-node rect {
            stroke-width: 2px;
            rx: 8;
            ry: 8;
            transition: stroke 0.2s, stroke-width 0.2s;
        }

        .workflow-node:hover rect {
            stroke-width: 3px;
            filter: brightness(1.1);
        }

        .workflow-node.selected rect {
            stroke: var(--accent-blue) !important;
            stroke-width: 3px;
        }

        .workflow-node text {
            fill: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .workflow-edge {
            cursor: pointer;
        }

        .workflow-edge path {
            fill: none;
            stroke: var(--border-color);
            stroke-width: 2px;
            transition: stroke 0.2s, stroke-width 0.2s;
        }

        .workflow-edge:hover path {
            stroke: var(--text-secondary);
            stroke-width: 3px;
        }

        .workflow-edge.selected path {
            stroke: var(--accent-blue);
            stroke-width: 3px;
        }

        .workflow-edge-label {
            fill: var(--text-muted);
            font-size: 10px;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .workflow-edge-arrow {
            fill: var(--border-color);
        }

        .workflow-edge:hover .workflow-edge-arrow {
            fill: var(--text-secondary);
        }

        .workflow-edge.selected .workflow-edge-arrow {
            fill: var(--accent-blue);
        }

        /* Phase type colors */
        .workflow-node.type-execute rect {
            fill: rgba(210, 153, 34, 0.2);
            stroke: #d29922;
        }

        .workflow-node.type-evaluate rect {
            fill: rgba(163, 113, 247, 0.2);
            stroke: #a371f7;
        }

        .workflow-node.type-script rect {
            fill: rgba(219, 109, 40, 0.2);
            stroke: #db6d28;
        }

        .workflow-node.type-terminal rect {
            fill: rgba(63, 185, 80, 0.2);
            stroke: #3fb950;
        }

        /* Workflow Graph Zoom Controls */
        .workflow-zoom-controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }

        .workflow-zoom-controls button {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .workflow-zoom-controls button:hover {
            background: var(--bg-hover);
            border-color: var(--text-secondary);
        }

        .workflow-zoom-controls button:active {
            background: var(--bg-active);
        }

        .workflow-zoom-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .workflow-zoom-controls .zoom-level {
            font-size: 11px;
            text-align: center;
            color: var(--text-muted);
            padding: 4px 0;
            min-width: 36px;
        }

        .workflow-zoom-controls .zoom-divider {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* Fit to view icon using CSS */
        .workflow-zoom-controls .btn-fit::before {
            content: '⊡';
            font-size: 16px;
        }

        .workflow-zoom-controls .btn-reset::before {
            content: '⌖';
            font-size: 16px;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="brand">
                <div class="brand-icon">R</div>
                <span class="brand-text">Jeeves Viewer</span>
            </div>
            <div class="header-status">
                <div class="iteration-badge" id="iterationBadge" style="display: none;">
                    <span class="number" id="iterationNumber">1</span>
                    <span class="label">of <span id="iterationMax">10</span></span>
                </div>
                <div class="connection-indicator">
                    <span class="connection-dot" id="connectionDot"></span>
                    <span id="connectionText">Connecting...</span>
                </div>
                <span class="status-badge idle" id="statusBadge">Idle</span>
            </div>
        </div>
    </header>
    
    <main class="main">
        <aside class="sidebar">
            <div class="panel-tabs">
                <button class="tab-btn active" id="sidebarTabSetup">Setup</button>
                <button class="tab-btn" id="sidebarTabMonitor">Monitor</button>
            </div>

            <div id="sidebarSetupSection">
            <!-- Controls -->
            <div class="card">
                <div class="card-header">Controls</div>
                <div class="card-body">
                    <div class="control-row">
                        <div class="control-label">Phase</div>
                        <select class="control-input" id="runPhase">
                            <!-- Populated dynamically from /api/workflow -->
                        </select>
                    </div>
                    <div class="control-row">
                        <div class="control-label">Max turns</div>
                        <input class="control-input" id="runMaxTurns" type="number" min="1" max="10000" value="10" />
                    </div>
                    <div class="control-actions">
                        <button class="log-btn active" id="btnRun">Run</button>
                    </div>
                </div>
            </div>

            <!-- Init Issue -->
            <div class="card">
                <div class="card-header">Init Issue</div>
                <div class="card-body">
                    <div class="control-row">
                        <div class="control-label">Issue (number or URL)</div>
                        <input class="control-input" id="initIssueNumber" type="text" placeholder="e.g. 590 or https://github.com/org/repo/issues/590" />
                    </div>
                    <div class="control-row">
                        <div class="control-label">Design doc (optional)</div>
                        <input class="control-input" id="initDesignDoc" type="text" placeholder="e.g. docs/issue-590-design.md" />
                    </div>
                    <div class="control-row">
                        <div class="control-label">Repo (optional)</div>
                        <input class="control-input" id="initRepo" type="text" placeholder="e.g. owner/repo" />
                    </div>
                    <div class="control-row">
                        <div class="control-label">Branch (optional)</div>
                        <input class="control-input" id="initBranch" type="text" placeholder="e.g. issue/590-some-slug" />
                    </div>
                    <div class="control-row">
                        <label class="control-label"><input type="checkbox" id="initForce" /> Force overwrite</label>
                    </div>
                    <div class="control-actions">
                        <button class="log-btn active" id="btnInitIssue">Init</button>
                    </div>
                    <div class="control-status" id="initStatusText"></div>
                </div>
            </div>
            </div>

            <div id="sidebarMonitorSection" style="display: none;">
            <div class="card">
                <div class="card-header">Run</div>
                <div class="card-body">
                    <div class="control-actions">
                        <button class="log-btn" id="btnStop">Stop</button>
                    </div>
                    <div class="control-status" id="runStatusText"></div>
                </div>
            </div>

            <!-- Phase Progress -->
            <div class="card">
                <div class="card-header">Workflow Progress</div>
                <div class="card-body">
                    <div class="phase-timeline" id="phaseTimeline">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
            
            <!-- Status Info -->
            <div class="card">
                <div class="card-header">Details</div>
                <div class="card-body">
                    <div class="info-grid" id="infoGrid">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

            </div>
        </aside>
        
        <section class="card log-panel">
            <div class="log-header">
                <div class="panel-left">
                    <div class="panel-tabs">
                        <button class="tab-btn active" id="tabLogs">Logs</button>
                        <button class="tab-btn" id="tabSdk">SDK</button>
                        <button class="tab-btn" id="tabPrompts">Prompts</button>
                    </div>
                    <span class="log-count" id="logCount">0 lines</span>
                </div>
                <div class="log-controls" id="logControls">
                    <button class="log-btn" id="btnClear">Clear</button>
                    <button class="log-btn" id="btnHideDiffs">Hide diffs</button>
                    <button class="log-btn active" id="btnAutoScroll">Auto-scroll</button>
                </div>
            </div>
            <div class="search-container" id="logsSearchContainer">
                <input type="text" class="search-input" id="searchInput" placeholder="Filter logs... (Ctrl+F)">
            </div>
            <div class="log-body" id="logsBody">
                <div class="log-content" id="logContent">
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128196;</div>
                        <div>Waiting for logs...</div>
                    </div>
                </div>
            </div>
            <div class="prompt-panel" id="promptsBody" style="display: none;">
                <div class="prompt-toolbar">
                    <div class="prompt-file">
                        <div class="control-label">Prompt file</div>
                        <select class="control-input" id="promptSelect"></select>
                        <div class="prompt-tabs" id="promptTabs"></div>
                    </div>
                    <div class="control-actions">
                        <button class="log-btn" id="btnPromptReload">Reload</button>
                        <button class="log-btn active" id="btnPromptSave">Save</button>
                    </div>
                </div>
                <textarea class="control-textarea editor-textarea prompt-editor" id="promptEditor" placeholder="Select a prompt file..."></textarea>
                <div class="control-status" id="promptStatusText"></div>
            </div>
            <div class="sdk-panel" id="sdkBody" style="display: none;">
                <div class="sdk-toolbar">
                    <div class="sdk-stats" id="sdkStats">
                        <span class="sdk-stat" id="sdkProviderStat" style="display: none;"><span class="sdk-stat-label">Provider:</span> <span id="sdkProvider">-</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Session:</span> <span id="sdkSessionId">-</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Messages:</span> <span id="sdkMessageCount">0</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Tool calls:</span> <span id="sdkToolCount">0</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Duration:</span> <span id="sdkDuration">-</span></span>
                        <span class="sdk-stat" id="sdkTokensStat" style="display: none;"><span class="sdk-stat-label">Tokens:</span> <span id="sdkInputTokens">0</span> in / <span id="sdkOutputTokens">0</span> out <span class="context-bar-container"><span class="context-bar" id="sdkContextBar"></span></span> <span id="sdkContextPct">0%</span></span>
                        <span class="sdk-stat" id="sdkCostStat" style="display: none;"><span class="sdk-stat-label">Cost:</span> <span id="sdkCost">-</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Status:</span> <span id="sdkStatus" class="sdk-status-pending">-</span></span>
                    </div>
                    <div class="sdk-controls">
                        <button class="log-btn" id="btnSdkRefresh">Refresh</button>
                        <button class="log-btn" id="btnSdkTimeline">Timeline</button>
                        <button class="log-btn active" id="btnSdkAutoScroll">Auto-scroll</button>
                    </div>
                </div>
                <div class="sdk-content" id="sdkContent">
                    <div class="sdk-conversation" id="sdkConversation">
                        <div class="log-empty">
                            <div class="log-empty-icon">&#128172;</div>
                            <div>No SDK output available</div>
                            <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Run to see structured output (updates in real-time)</div>
                        </div>
                    </div>
                    <div class="sdk-timeline" id="sdkTimeline" style="display: none;"></div>
                </div>
            </div>
        </section>
    </main>
    
    <div class="keyboard-hint">
        <kbd>Ctrl</kbd>+<kbd>F</kbd> Filter &nbsp; <kbd>Esc</kbd> Clear filter &nbsp; <kbd>End</kbd> Jump to bottom
    </div>

    <script>
        // State
        let eventSource = null;
        let currentState = null;
        let allLogs = [];
        let autoScroll = true;
        let searchFilter = '';
        let hideDiffs = false;
        let reconnectAttempts = 0;
        let lastPhase = null;
        let notificationsEnabled = false;
        let renderScheduled = false;
        const MAX_LOGS = 5000;
        let promptListLoaded = false;
        let promptLoadedId = null;
        let promptDirty = false;
        let promptListPromise = null;
        let mainTab = 'sdk';
        let promptFiles = [];
        let sdkOutput = null;
        let sdkShowTimeline = false;
        let sdkAutoScroll = true;

        /**
         * WorkflowGraph - D3.js force-directed graph for workflow visualization
         *
         * Renders phases as nodes colored by type and transitions as directed edges.
         * Supports zoom/pan, node selection, and callbacks for interaction.
         */
        class WorkflowGraph {
            constructor(container, options = {}) {
                this.container = typeof container === 'string'
                    ? document.querySelector(container)
                    : container;

                if (!this.container) {
                    throw new Error('WorkflowGraph: container not found');
                }

                // Options with defaults
                this.options = {
                    nodeWidth: 140,
                    nodeHeight: 40,
                    onNodeSelect: options.onNodeSelect || null,
                    onEdgeSelect: options.onEdgeSelect || null,
                    ...options
                };

                // State
                this.workflow = null;
                this.nodes = [];
                this.links = [];
                this.selectedNode = null;
                this.selectedEdge = null;
                this.simulation = null;

                // Phase type colors
                this.typeColors = {
                    execute: '#d29922',
                    evaluate: '#a371f7',
                    script: '#db6d28',
                    terminal: '#3fb950'
                };

                // Initialize SVG and groups
                this._initSvg();
            }

            /**
             * Initialize SVG container and groups
             */
            _initSvg() {
                // Clear any existing content
                this.container.innerHTML = '';
                this.container.classList.add('workflow-graph-container');

                // Create SVG
                this.svg = d3.select(this.container)
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');

                // Get actual dimensions
                const rect = this.container.getBoundingClientRect();
                this.width = rect.width || 800;
                this.height = rect.height || 600;

                // Define arrow marker for edges
                const defs = this.svg.append('defs');
                defs.append('marker')
                    .attr('id', 'workflow-arrow')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 8)
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('class', 'workflow-edge-arrow');

                // Create zoom container group
                this.zoomGroup = this.svg.append('g')
                    .attr('class', 'zoom-container');

                // Create groups for edges and nodes (edges below nodes)
                this.edgeGroup = this.zoomGroup.append('g')
                    .attr('class', 'edges');
                this.nodeGroup = this.zoomGroup.append('g')
                    .attr('class', 'nodes');

                // Setup zoom behavior
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.zoomGroup.attr('transform', event.transform);
                    });

                this.svg.call(this.zoom);
            }

            /**
             * Render a workflow
             * @param {Object} workflow - Workflow data with phases
             */
            render(workflow) {
                if (!workflow || !workflow.phases) {
                    console.warn('WorkflowGraph.render: No workflow or phases provided');
                    return;
                }

                this.workflow = workflow;
                this._buildGraphData();
                this._createSimulation();
                this._renderElements();
            }

            /**
             * Build nodes and links from workflow data
             */
            _buildGraphData() {
                const phases = this.workflow.phases;
                this.nodes = [];
                this.links = [];

                // Handle both object and array format for phases
                const phaseEntries = Array.isArray(phases)
                    ? phases.map(p => [p.name || p.id, p])
                    : Object.entries(phases);

                // Create nodes from phases
                phaseEntries.forEach(([name, phase]) => {
                    this.nodes.push({
                        id: name,
                        name: phase.name || name,
                        type: phase.type || 'execute',
                        description: phase.description || '',
                        prompt: phase.prompt,
                        command: phase.command,
                        phase: phase  // Keep reference to original phase data
                    });
                });

                // Create links from transitions
                phaseEntries.forEach(([sourceName, phase]) => {
                    const transitions = phase.transitions || [];
                    transitions.forEach((transition, index) => {
                        const targetName = transition.to || transition.target;
                        if (targetName && this.nodes.find(n => n.id === targetName)) {
                            this.links.push({
                                id: `${sourceName}-${targetName}-${index}`,
                                source: sourceName,
                                target: targetName,
                                guard: transition.when || transition.guard || '',
                                auto: transition.auto || false,
                                priority: transition.priority || 0,
                                transition: transition  // Keep reference to original transition
                            });
                        }
                    });
                });
            }

            /**
             * Create D3 force simulation
             */
            _createSimulation() {
                // Stop any existing simulation
                if (this.simulation) {
                    this.simulation.stop();
                }

                // Get container dimensions
                const rect = this.container.getBoundingClientRect();
                this.width = rect.width || 800;
                this.height = rect.height || 600;

                // Create force simulation
                this.simulation = d3.forceSimulation(this.nodes)
                    .force('link', d3.forceLink(this.links)
                        .id(d => d.id)
                        .distance(180)
                        .strength(0.5))
                    .force('charge', d3.forceManyBody()
                        .strength(-400))
                    .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                    .force('collision', d3.forceCollide()
                        .radius(this.options.nodeWidth / 2 + 20))
                    .on('tick', () => this._tick());

                // Run simulation for initial positions
                this.simulation.alpha(1).restart();
            }

            /**
             * Render SVG elements for nodes and edges
             */
            _renderElements() {
                this._renderEdges();
                this._renderNodes();
            }

            /**
             * Render edge elements
             */
            _renderEdges() {
                // Remove existing edges
                this.edgeGroup.selectAll('.workflow-edge').remove();

                // Create edge groups
                const edgeSelection = this.edgeGroup.selectAll('.workflow-edge')
                    .data(this.links, d => d.id)
                    .enter()
                    .append('g')
                    .attr('class', 'workflow-edge')
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        this._selectEdge(d);
                    });

                // Add path for each edge
                edgeSelection.append('path')
                    .attr('marker-end', 'url(#workflow-arrow)');

                // Add label for guard expression
                edgeSelection.append('text')
                    .attr('class', 'workflow-edge-label')
                    .text(d => this._formatGuardLabel(d.guard));

                this.edgeElements = this.edgeGroup.selectAll('.workflow-edge');
            }

            /**
             * Format guard expression for display as edge label
             */
            _formatGuardLabel(guard) {
                if (!guard) return '';
                // Truncate long guards
                if (guard.length > 30) {
                    return guard.substring(0, 27) + '...';
                }
                return guard;
            }

            /**
             * Render node elements
             */
            _renderNodes() {
                // Remove existing nodes
                this.nodeGroup.selectAll('.workflow-node').remove();

                const self = this;
                const { nodeWidth, nodeHeight } = this.options;

                // Create node groups
                const nodeSelection = this.nodeGroup.selectAll('.workflow-node')
                    .data(this.nodes, d => d.id)
                    .enter()
                    .append('g')
                    .attr('class', d => `workflow-node type-${d.type}`)
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        this._selectNode(d);
                    })
                    .call(d3.drag()
                        .on('start', (event, d) => this._dragStarted(event, d))
                        .on('drag', (event, d) => this._dragged(event, d))
                        .on('end', (event, d) => this._dragEnded(event, d)));

                // Add rectangle for each node
                nodeSelection.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight)
                    .attr('x', -nodeWidth / 2)
                    .attr('y', -nodeHeight / 2);

                // Add text label
                nodeSelection.append('text')
                    .text(d => d.name)
                    .attr('dy', '0.35em');

                this.nodeElements = this.nodeGroup.selectAll('.workflow-node');

                // Click on background to deselect
                this.svg.on('click', () => {
                    this._clearSelection();
                });
            }

            /**
             * Update positions on simulation tick
             */
            _tick() {
                // Update edge paths
                if (this.edgeElements) {
                    this.edgeElements.select('path')
                        .attr('d', d => this._calculateEdgePath(d));

                    // Update edge label positions
                    this.edgeElements.select('text')
                        .attr('x', d => (d.source.x + d.target.x) / 2)
                        .attr('y', d => (d.source.y + d.target.y) / 2 - 10);
                }

                // Update node positions
                if (this.nodeElements) {
                    this.nodeElements.attr('transform', d => `translate(${d.x}, ${d.y})`);
                }
            }

            /**
             * Calculate edge path accounting for node dimensions
             */
            _calculateEdgePath(d) {
                const { nodeWidth, nodeHeight } = this.options;

                // Source and target positions
                const sx = d.source.x;
                const sy = d.source.y;
                const tx = d.target.x;
                const ty = d.target.y;

                // Calculate angle
                const angle = Math.atan2(ty - sy, tx - sx);

                // Calculate edge points at node boundaries
                const sourceX = sx + Math.cos(angle) * (nodeWidth / 2);
                const sourceY = sy + Math.sin(angle) * (nodeHeight / 2);
                const targetX = tx - Math.cos(angle) * (nodeWidth / 2 + 10);  // Extra offset for arrow
                const targetY = ty - Math.sin(angle) * (nodeHeight / 2 + 10);

                return `M${sourceX},${sourceY}L${targetX},${targetY}`;
            }

            /**
             * Drag event handlers
             */
            _dragStarted(event, d) {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            _dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            _dragEnded(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                // Keep the node fixed at its dragged position
                // d.fx = null;
                // d.fy = null;
            }

            /**
             * Selection handlers
             */
            _selectNode(node) {
                this._clearSelection();
                this.selectedNode = node;

                // Update visual state
                this.nodeElements
                    .classed('selected', d => d.id === node.id);

                // Trigger callback
                if (this.options.onNodeSelect) {
                    this.options.onNodeSelect(node);
                }
            }

            _selectEdge(edge) {
                this._clearSelection();
                this.selectedEdge = edge;

                // Update visual state
                this.edgeElements
                    .classed('selected', d => d.id === edge.id);

                // Trigger callback
                if (this.options.onEdgeSelect) {
                    this.options.onEdgeSelect(edge);
                }
            }

            _clearSelection() {
                this.selectedNode = null;
                this.selectedEdge = null;

                if (this.nodeElements) {
                    this.nodeElements.classed('selected', false);
                }
                if (this.edgeElements) {
                    this.edgeElements.classed('selected', false);
                }
            }

            /**
             * Public API methods
             */

            /**
             * Set selection programmatically
             */
            setSelection(type, id) {
                this._clearSelection();

                if (type === 'node') {
                    const node = this.nodes.find(n => n.id === id);
                    if (node) this._selectNode(node);
                } else if (type === 'edge') {
                    const edge = this.links.find(l => l.id === id);
                    if (edge) this._selectEdge(edge);
                }
            }

            /**
             * Update a single node's data and re-render
             */
            updateNode(nodeId, data) {
                const node = this.nodes.find(n => n.id === nodeId);
                if (node) {
                    Object.assign(node, data);
                    this._renderNodes();
                }
            }

            /**
             * Get current selection
             */
            getSelection() {
                if (this.selectedNode) {
                    return { type: 'node', data: this.selectedNode };
                }
                if (this.selectedEdge) {
                    return { type: 'edge', data: this.selectedEdge };
                }
                return null;
            }

            /**
             * Resize handler - call when container size changes
             */
            resize() {
                const rect = this.container.getBoundingClientRect();
                this.width = rect.width || 800;
                this.height = rect.height || 600;

                if (this.simulation) {
                    this.simulation.force('center', d3.forceCenter(this.width / 2, this.height / 2));
                    this.simulation.alpha(0.3).restart();
                }
            }

            /**
             * Zoom in by a fixed step
             * @param {number} step - Zoom increment (default 0.3)
             */
            zoomIn(step = 0.3) {
                this.svg.transition()
                    .duration(300)
                    .call(this.zoom.scaleBy, 1 + step);
            }

            /**
             * Zoom out by a fixed step
             * @param {number} step - Zoom decrement (default 0.3)
             */
            zoomOut(step = 0.3) {
                this.svg.transition()
                    .duration(300)
                    .call(this.zoom.scaleBy, 1 - step);
            }

            /**
             * Fit the graph to the viewport, centering and scaling appropriately
             */
            fitToView() {
                if (!this.nodes || this.nodes.length === 0) {
                    return;
                }

                // Calculate bounding box of all nodes
                const padding = 50;
                const { nodeWidth, nodeHeight } = this.options;

                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                this.nodes.forEach(node => {
                    const x = node.x || 0;
                    const y = node.y || 0;
                    minX = Math.min(minX, x - nodeWidth / 2);
                    maxX = Math.max(maxX, x + nodeWidth / 2);
                    minY = Math.min(minY, y - nodeHeight / 2);
                    maxY = Math.max(maxY, y + nodeHeight / 2);
                });

                const graphWidth = maxX - minX + padding * 2;
                const graphHeight = maxY - minY + padding * 2;

                // Get viewport dimensions
                const rect = this.container.getBoundingClientRect();
                const viewportWidth = rect.width || 800;
                const viewportHeight = rect.height || 600;

                // Calculate scale to fit
                const scaleX = viewportWidth / graphWidth;
                const scaleY = viewportHeight / graphHeight;
                const scale = Math.min(scaleX, scaleY, 2); // Cap at 2x zoom

                // Calculate center offset
                const graphCenterX = (minX + maxX) / 2;
                const graphCenterY = (minY + maxY) / 2;

                const translateX = viewportWidth / 2 - graphCenterX * scale;
                const translateY = viewportHeight / 2 - graphCenterY * scale;

                // Apply transform with animation
                const transform = d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale);

                this.svg.transition()
                    .duration(500)
                    .call(this.zoom.transform, transform);
            }

            /**
             * Reset zoom to default (1:1 scale, centered)
             */
            resetZoom() {
                const rect = this.container.getBoundingClientRect();
                const transform = d3.zoomIdentity
                    .translate(0, 0)
                    .scale(1);

                this.svg.transition()
                    .duration(300)
                    .call(this.zoom.transform, transform);
            }

            /**
             * Get the current zoom level
             * @returns {number} Current zoom scale
             */
            getZoomLevel() {
                const transform = d3.zoomTransform(this.svg.node());
                return transform.k;
            }

            /**
             * Set zoom level to a specific value
             * @param {number} level - Target zoom level
             */
            setZoomLevel(level) {
                this.svg.transition()
                    .duration(300)
                    .call(this.zoom.scaleTo, level);
            }

            /**
             * Center on a specific node
             * @param {string} nodeId - ID of the node to center on
             */
            centerOnNode(nodeId) {
                const node = this.nodes.find(n => n.id === nodeId);
                if (!node) return;

                const rect = this.container.getBoundingClientRect();
                const viewportWidth = rect.width || 800;
                const viewportHeight = rect.height || 600;

                // Get current zoom level to preserve it
                const currentTransform = d3.zoomTransform(this.svg.node());
                const scale = currentTransform.k;

                const translateX = viewportWidth / 2 - node.x * scale;
                const translateY = viewportHeight / 2 - node.y * scale;

                const transform = d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale);

                this.svg.transition()
                    .duration(500)
                    .call(this.zoom.transform, transform);
            }

            /**
             * Destroy the graph and clean up
             */
            destroy() {
                if (this.simulation) {
                    this.simulation.stop();
                }
                if (this.container) {
                    this.container.innerHTML = '';
                    this.container.classList.remove('workflow-graph-container');
                }
            }
        }

        // Schema version detection and normalization functions
        function detectSchemaVersion(data) {
            // Detect schema version from the 'schema' field
            // Returns 'v1', 'v2', or 'unknown'
            if (!data || typeof data !== 'object') return 'unknown';
            const schema = data.schema;
            if (schema === 'jeeves.sdk.v1') return 'v1';
            if (schema === 'jeeves.output.v2') return 'v2';
            // Fallback: detect by structure
            if (data.session && data.conversation) return 'v2';
            if (data.session_id !== undefined && data.messages !== undefined) return 'v1';
            return 'unknown';
        }

        function normalizeSdkOutput(data) {
            // Normalize both v1 and v2 schemas to a common internal format for rendering.
            // Returns an object with: session_id, messages, tool_calls, stats, success, error,
            // schemaVersion, and provider (for v2).
            if (!data || typeof data !== 'object') return null;

            const version = detectSchemaVersion(data);

            if (version === 'v2') {
                // v2 schema: uses session.id, conversation, summary, provider
                // Extract token counts from summary.tokens when available
                const tokens = data.summary?.tokens || null;
                return {
                    schemaVersion: 'v2',
                    session_id: data.session?.id || null,
                    messages: data.conversation || [],
                    tool_calls: data.tool_calls || [],
                    stats: {
                        message_count: data.summary?.message_count || (data.conversation?.length || 0),
                        tool_call_count: data.summary?.tool_call_count || (data.tool_calls?.length || 0),
                        duration_seconds: data.summary?.duration_seconds || 0,
                        context_percentage: data.summary?.context_percentage,
                        context_window_size: data.summary?.context_window_size,
                        cost_usd: data.summary?.cost_usd,
                    },
                    // Token tracking (when provider supports it)
                    tokens: tokens,
                    // v2 uses session.status enum: running, success, error, cancelled
                    success: data.session?.status === 'success',
                    error: data.session?.status === 'error' ? (data.summary?.errors?.[0]?.message || 'Error') : null,
                    status: data.session?.status || 'running',
                    provider: data.provider || null,
                    started_at: data.session?.started_at,
                    ended_at: data.session?.ended_at,
                };
            } else {
                // v1 schema (default): uses session_id, messages, stats directly
                // Extract token counts from stats.tokens when available
                const tokens = data.stats?.tokens || null;
                // Copy stats but ensure we have all the fields we need
                const stats = data.stats ? { ...data.stats } : {
                    message_count: data.messages?.length || 0,
                    tool_call_count: data.tool_calls?.length || 0,
                    duration_seconds: 0,
                };
                return {
                    schemaVersion: 'v1',
                    session_id: data.session_id || null,
                    messages: data.messages || [],
                    tool_calls: data.tool_calls || [],
                    stats: stats,
                    // Token tracking (when provider supports it)
                    tokens: tokens,
                    success: data.success,
                    error: data.error || null,
                    status: data.success ? 'success' : (data.error ? 'error' : (data.ended_at ? 'complete' : 'running')),
                    provider: null,  // v1 does not have provider info
                    started_at: data.started_at,
                    ended_at: data.ended_at,
                };
            }
        }

        // SDK output functions
        async function loadSdkOutput() {
            try {
                const response = await fetch('/api/sdk-output', { cache: 'no-store' });
                if (!response.ok) {
                    if (response.status === 404) {
                        sdkOutput = null;
                        renderSdkOutput();
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                if (data.ok && data.output) {
                    // Normalize v1/v2 schema to common format
                    sdkOutput = normalizeSdkOutput(data.output);
                    renderSdkOutput();
                }
            } catch (e) {
                console.error('Failed to load SDK output:', e);
            }
        }

        function renderSdkOutput() {
            const providerStatEl = document.getElementById('sdkProviderStat');
            const providerEl = document.getElementById('sdkProvider');
            const sessionEl = document.getElementById('sdkSessionId');
            const msgCountEl = document.getElementById('sdkMessageCount');
            const toolCountEl = document.getElementById('sdkToolCount');
            const durationEl = document.getElementById('sdkDuration');
            const statusEl = document.getElementById('sdkStatus');
            const convEl = document.getElementById('sdkConversation');
            const timelineEl = document.getElementById('sdkTimeline');
            const tokensStatEl = document.getElementById('sdkTokensStat');
            const inputTokensEl = document.getElementById('sdkInputTokens');
            const outputTokensEl = document.getElementById('sdkOutputTokens');
            const contextBarEl = document.getElementById('sdkContextBar');
            const contextPctEl = document.getElementById('sdkContextPct');
            const costStatEl = document.getElementById('sdkCostStat');
            const costEl = document.getElementById('sdkCost');

            if (!sdkOutput) {
                if (providerStatEl) providerStatEl.style.display = 'none';
                if (tokensStatEl) tokensStatEl.style.display = 'none';
                if (costStatEl) costStatEl.style.display = 'none';
                sessionEl.textContent = '-';
                msgCountEl.textContent = '0';
                toolCountEl.textContent = '0';
                durationEl.textContent = '-';
                statusEl.textContent = '-';
                statusEl.className = 'sdk-status-pending';
                if (contextBarEl) {
                    contextBarEl.style.width = '0%';
                    contextBarEl.className = 'context-bar';
                }
                if (contextPctEl) contextPctEl.textContent = '0%';
                convEl.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128172;</div>
                        <div>No SDK output available</div>
                        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Run to see structured output (updates in real-time)</div>
                    </div>
                `;
                timelineEl.innerHTML = '';
                return;
            }

            // Show provider info for v2 schema
            if (sdkOutput.schemaVersion === 'v2' && sdkOutput.provider) {
                const providerName = sdkOutput.provider.name || 'unknown';
                const providerVersion = sdkOutput.provider.version || '';
                providerEl.textContent = providerVersion ? `${providerName} ${providerVersion}` : providerName;
                if (providerStatEl) providerStatEl.style.display = 'inline';
            } else {
                if (providerStatEl) providerStatEl.style.display = 'none';
            }

            // Update stats
            sessionEl.textContent = sdkOutput.session_id ? sdkOutput.session_id.substring(0, 12) + '...' : '-';
            msgCountEl.textContent = String(sdkOutput.stats?.message_count || sdkOutput.messages?.length || 0);
            toolCountEl.textContent = String(sdkOutput.stats?.tool_call_count || sdkOutput.tool_calls?.length || 0);

            const duration = sdkOutput.stats?.duration_seconds;
            durationEl.textContent = duration ? `${duration.toFixed(1)}s` : '-';

            // Show token stats when available (provider supports token tracking)
            if (sdkOutput.tokens && (sdkOutput.tokens.input > 0 || sdkOutput.tokens.output > 0)) {
                inputTokensEl.textContent = sdkOutput.tokens.input.toLocaleString();
                outputTokensEl.textContent = sdkOutput.tokens.output.toLocaleString();
                if (tokensStatEl) tokensStatEl.style.display = 'inline';

                // Update context bar (percentage is now bounded 0-100 from server)
                const contextPct = sdkOutput.stats?.context_percentage || 0;
                if (contextBarEl) {
                    // No Math.min needed - already bounded from server
                    contextBarEl.style.width = `${contextPct}%`;
                    // Color based on usage level
                    contextBarEl.className = 'context-bar ' + (
                        contextPct >= 80 ? 'context-high' :
                        contextPct >= 50 ? 'context-medium' : 'context-low'
                    );
                }
                if (contextPctEl) {
                    // Already bounded from server
                    contextPctEl.textContent = `${contextPct.toFixed(1)}%`;
                }
            } else {
                if (tokensStatEl) tokensStatEl.style.display = 'none';
                if (contextBarEl) {
                    contextBarEl.style.width = '0%';
                    contextBarEl.className = 'context-bar';
                }
                if (contextPctEl) contextPctEl.textContent = '0%';
            }

            // Show cost when available
            if (sdkOutput.stats?.cost_usd !== undefined && sdkOutput.stats?.cost_usd !== null) {
                costEl.textContent = `$${sdkOutput.stats.cost_usd.toFixed(4)}`;
                if (costStatEl) costStatEl.style.display = 'inline';
            } else {
                if (costStatEl) costStatEl.style.display = 'none';
            }

            // Handle v2 session.status or v1 success/error
            if (sdkOutput.status === 'success' || sdkOutput.success) {
                statusEl.textContent = 'Success';
                statusEl.className = 'sdk-status-success';
            } else if (sdkOutput.status === 'error' || sdkOutput.error) {
                statusEl.textContent = 'Error';
                statusEl.className = 'sdk-status-error';
            } else if (sdkOutput.status === 'cancelled') {
                statusEl.textContent = 'Cancelled';
                statusEl.className = 'sdk-status-pending';
            } else {
                statusEl.textContent = 'Running';
                statusEl.className = 'sdk-status-pending';
            }

            // Render conversation view
            if (sdkShowTimeline) {
                convEl.style.display = 'none';
                timelineEl.style.display = 'block';
                renderSdkTimeline();
            } else {
                convEl.style.display = 'block';
                timelineEl.style.display = 'none';
                renderSdkConversation();
            }
        }

        function renderSdkConversation() {
            const convEl = document.getElementById('sdkConversation');
            if (!sdkOutput || !sdkOutput.messages || sdkOutput.messages.length === 0) {
                convEl.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128172;</div>
                        <div>No messages</div>
                    </div>
                `;
                return;
            }

            const html = sdkOutput.messages.map(msg => {
                const type = msg.type || 'unknown';
                const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '';
                let contentHtml = '';

                if (msg.content) {
                    contentHtml = `<div class="sdk-message-content">${escapeHtml(truncateText(msg.content, 1000))}</div>`;
                }

                let toolHtml = '';
                if (msg.tool_use) {
                    const inputStr = JSON.stringify(msg.tool_use.input || {}, null, 2);
                    toolHtml = `
                        <div class="sdk-tool-use">
                            <span class="sdk-tool-name">${escapeHtml(msg.tool_use.name)}</span>
                            <div class="sdk-tool-input">${escapeHtml(truncateText(inputStr, 300))}</div>
                        </div>
                    `;
                }

                return `
                    <div class="sdk-message ${type}">
                        <div class="sdk-message-header">
                            <span class="sdk-message-type">${type}${msg.subtype ? ` (${msg.subtype})` : ''}</span>
                            <span>${timestamp}</span>
                        </div>
                        ${contentHtml}
                        ${toolHtml}
                    </div>
                `;
            }).join('');

            convEl.innerHTML = html;
            if (sdkAutoScroll) {
                convEl.scrollTop = convEl.scrollHeight;
            }
        }

        function renderSdkTimeline() {
            const timelineEl = document.getElementById('sdkTimeline');
            if (!sdkOutput || !sdkOutput.tool_calls || sdkOutput.tool_calls.length === 0) {
                timelineEl.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#9202;</div>
                        <div>No tool calls</div>
                    </div>
                `;
                return;
            }

            // Find max duration for scaling
            const maxDuration = Math.max(...sdkOutput.tool_calls.map(t => t.duration_ms || 0), 1);

            const html = sdkOutput.tool_calls.map(call => {
                const duration = call.duration_ms || 0;
                const percent = Math.min(100, (duration / maxDuration) * 100);
                const durationStr = duration >= 1000 ? `${(duration / 1000).toFixed(1)}s` : `${duration}ms`;

                return `
                    <div class="sdk-timeline-item">
                        <div class="sdk-timeline-name">${escapeHtml(call.name)}</div>
                        <div class="sdk-timeline-bar">
                            <div class="sdk-timeline-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="sdk-timeline-duration">${durationStr}</div>
                    </div>
                `;
            }).join('');

            timelineEl.innerHTML = html;
            if (sdkAutoScroll) {
                timelineEl.scrollTop = timelineEl.scrollHeight;
            }
        }

        function truncateText(text, maxLen) {
            if (!text) return '';
            if (text.length <= maxLen) return text;
            return text.substring(0, maxLen) + '...';
        }

        async function resyncLogs() {
            try {
                const response = await fetch('/api/logs', { cache: 'no-store' });
                if (!response.ok) return;
                const data = await response.json();
                if (data && Array.isArray(data.logs)) {
                    allLogs = data.logs.slice(-MAX_LOGS);
                    scheduleRender();
                }
            } catch (e) {
                console.warn('Failed to resync logs:', e);
            }
        }

        function scheduleRender() {
            if (renderScheduled) return;
            renderScheduled = true;
            requestAnimationFrame(() => {
                renderScheduled = false;
                renderLogs();
            });
        }
        
        // Request notification permission on load
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission().then(perm => {
                notificationsEnabled = perm === 'granted';
            });
        } else if ('Notification' in window) {
            notificationsEnabled = Notification.permission === 'granted';
        }
        
        // Audio notification (simple beep using Web Audio API)
        function playNotificationSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                // Pleasant notification sound
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.5);
                
                // Second tone for completion
                setTimeout(() => {
                    const osc2 = audioCtx.createOscillator();
                    const gain2 = audioCtx.createGain();
                    osc2.connect(gain2);
                    gain2.connect(audioCtx.destination);
                    osc2.frequency.value = 1000;
                    osc2.type = 'sine';
                    gain2.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc2.start(audioCtx.currentTime);
                    osc2.stop(audioCtx.currentTime + 0.5);
                }, 200);
            } catch (e) {
                console.log('Audio notification not available');
            }
        }
        
        function showNotification(title, body) {
            // Play sound
            playNotificationSound();
            
            // Browser notification
            if (notificationsEnabled) {
                new Notification(title, {
                    body: body,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">R</text></svg>'
                });
            }
        }
        
        // DOM elements
        const logContent = document.getElementById('logContent');
        const logCount = document.getElementById('logCount');
        const searchInput = document.getElementById('searchInput');
        const logsSearchContainer = document.getElementById('logsSearchContainer');
        const logsBody = document.getElementById('logsBody');
        const promptsBody = document.getElementById('promptsBody');
        const sdkBody = document.getElementById('sdkBody');
        const tabLogs = document.getElementById('tabLogs');
        const tabSdk = document.getElementById('tabSdk');
        const tabPrompts = document.getElementById('tabPrompts');
        const btnSdkRefresh = document.getElementById('btnSdkRefresh');
        const btnSdkTimeline = document.getElementById('btnSdkTimeline');
        const btnSdkAutoScroll = document.getElementById('btnSdkAutoScroll');
        const btnAutoScroll = document.getElementById('btnAutoScroll');
        const btnClear = document.getElementById('btnClear');
        const btnHideDiffs = document.getElementById('btnHideDiffs');
        const logControls = document.getElementById('logControls');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const statusBadge = document.getElementById('statusBadge');
        const iterationBadge = document.getElementById('iterationBadge');
        const iterationNumber = document.getElementById('iterationNumber');
        const iterationMax = document.getElementById('iterationMax');
        const phaseTimeline = document.getElementById('phaseTimeline');
        const infoGrid = document.getElementById('infoGrid');
        const statusChecks = document.getElementById('statusChecks');
        const checksCard = document.getElementById('checksCard');
        const runPhase = document.getElementById('runPhase');
        const runMaxTurns = document.getElementById('runMaxTurns');
        const btnRun = document.getElementById('btnRun');
        const btnStop = document.getElementById('btnStop');
        const runStatusText = document.getElementById('runStatusText');

        let runIsRunning = false;

        const sidebarTabSetup = document.getElementById('sidebarTabSetup');
        const sidebarTabMonitor = document.getElementById('sidebarTabMonitor');
        const sidebarSetupSection = document.getElementById('sidebarSetupSection');
        const sidebarMonitorSection = document.getElementById('sidebarMonitorSection');

        const promptSelect = document.getElementById('promptSelect');
        const promptTabs = document.getElementById('promptTabs');
        const promptEditor = document.getElementById('promptEditor');
        const btnPromptReload = document.getElementById('btnPromptReload');
        const btnPromptSave = document.getElementById('btnPromptSave');
        const promptStatusText = document.getElementById('promptStatusText');

        const initIssueNumber = document.getElementById('initIssueNumber');
        const initDesignDoc = document.getElementById('initDesignDoc');
        const initRepo = document.getElementById('initRepo');
        const initBranch = document.getElementById('initBranch');
        const initForce = document.getElementById('initForce');
        const btnInitIssue = document.getElementById('btnInitIssue');
        const initStatusText = document.getElementById('initStatusText');
        
        function updateHideDiffsButton() {
            if (!btnHideDiffs) return;
            btnHideDiffs.classList.toggle('active', hideDiffs);
            btnHideDiffs.textContent = hideDiffs ? 'Show diffs' : 'Hide diffs';
        }

        try {
            hideDiffs = localStorage.getItem('jeeves_viewer_hide_diffs') === '1';
        } catch (e) {
            // ignore
        }
        updateHideDiffsButton();

        // Phase definitions - populated dynamically from /api/workflow
        let phases = [
            { id: 'design_draft', name: 'Design Draft', desc: 'Create initial design document' },
            { id: 'design_review', name: 'Design Review', desc: 'Review design document' },
            { id: 'design_edit', name: 'Design Edit', desc: 'Apply changes from design review' },
            { id: 'implement', name: 'Implement', desc: 'Implement the design' },
            { id: 'code_review', name: 'Code Review', desc: 'Review code changes' },
            { id: 'code_fix', name: 'Code Fix', desc: 'Apply fixes from code review' },
            { id: 'complete', name: 'Complete', desc: 'Workflow complete' }
        ];

        let phaseOrder = ['design_draft', 'design_review', 'design_edit', 'implement', 'code_review', 'code_fix', 'complete'];

        function getPhaseIndex(phase) {
            return phaseOrder.indexOf(phase);
        }

        // Fetch workflow phases from API
        async function fetchWorkflow() {
            try {
                const response = await fetch('/api/workflow');
                const data = await response.json();
                if (data.ok && data.phases && data.phase_order) {
                    phases = data.phases.map(p => ({
                        id: p.id,
                        name: p.name,
                        desc: p.description || ''
                    }));
                    phaseOrder = data.phase_order;

                    // Update the phase dropdown
                    const runPhase = document.getElementById('runPhase');
                    if (runPhase) {
                        runPhase.innerHTML = phases.map(p =>
                            `<option value="${p.id}">${p.name}</option>`
                        ).join('');

                        // Set current phase if available
                        if (data.current_phase && phaseOrder.includes(data.current_phase)) {
                            runPhase.value = data.current_phase;
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to fetch workflow:', e);
                // Fall back to default phases - populate dropdown anyway
                const runPhase = document.getElementById('runPhase');
                if (runPhase && runPhase.options.length === 0) {
                    runPhase.innerHTML = phases.map(p =>
                        `<option value="${p.id}">${p.name}</option>`
                    ).join('');
                }
            }
        }

        let sidebarTab = 'setup';

        function setSidebarTab(tab) {
            sidebarTab = tab === 'monitor' ? 'monitor' : 'setup';
            if (sidebarTabSetup) sidebarTabSetup.classList.toggle('active', sidebarTab === 'setup');
            if (sidebarTabMonitor) sidebarTabMonitor.classList.toggle('active', sidebarTab === 'monitor');
            if (sidebarSetupSection) sidebarSetupSection.style.display = sidebarTab === 'setup' ? 'block' : 'none';
            if (sidebarMonitorSection) sidebarMonitorSection.style.display = sidebarTab === 'monitor' ? 'block' : 'none';

            try {
                localStorage.setItem('jeeves_viewer_sidebar_tab', sidebarTab);
            } catch (e) {
                // ignore
            }
        }

        if (sidebarTabSetup) sidebarTabSetup.addEventListener('click', () => setSidebarTab('setup'));
        if (sidebarTabMonitor) sidebarTabMonitor.addEventListener('click', () => setSidebarTab('monitor'));

        try {
            const savedSidebar = localStorage.getItem('jeeves_viewer_sidebar_tab');
            setSidebarTab(savedSidebar || 'setup');
        } catch (e) {
            setSidebarTab('setup');
        }

        function setMainTab(tab) {
            if (tab === 'prompts') mainTab = 'prompts';
            else if (tab === 'sdk') mainTab = 'sdk';
            else mainTab = 'logs';

            if (tabLogs) tabLogs.classList.toggle('active', mainTab === 'logs');
            if (tabSdk) tabSdk.classList.toggle('active', mainTab === 'sdk');
            if (tabPrompts) tabPrompts.classList.toggle('active', mainTab === 'prompts');

            if (logsSearchContainer) logsSearchContainer.style.display = mainTab === 'logs' ? 'block' : 'none';
            if (logsBody) logsBody.style.display = mainTab === 'logs' ? 'flex' : 'none';
            if (logControls) logControls.style.display = mainTab === 'logs' ? 'flex' : 'none';
            if (logCount) logCount.style.display = mainTab === 'logs' ? 'inline-block' : 'none';

            if (promptsBody) promptsBody.style.display = mainTab === 'prompts' ? 'flex' : 'none';
            if (mainTab === 'prompts' && promptEditor) promptEditor.focus();

            if (sdkBody) sdkBody.style.display = mainTab === 'sdk' ? 'flex' : 'none';
            if (mainTab === 'sdk') loadSdkOutput();

            try {
                localStorage.setItem('jeeves_viewer_main_tab', mainTab);
            } catch (e) {
                // ignore
            }
        }

        if (tabLogs) tabLogs.addEventListener('click', () => setMainTab('logs'));
        if (tabSdk) tabSdk.addEventListener('click', () => setMainTab('sdk'));
        if (tabPrompts) tabPrompts.addEventListener('click', () => setMainTab('prompts'));

        if (btnSdkRefresh) btnSdkRefresh.addEventListener('click', () => loadSdkOutput());
        if (btnSdkTimeline) btnSdkTimeline.addEventListener('click', () => {
            sdkShowTimeline = !sdkShowTimeline;
            btnSdkTimeline.classList.toggle('active', sdkShowTimeline);
            btnSdkTimeline.textContent = sdkShowTimeline ? 'Conversation' : 'Timeline';
            renderSdkOutput();
        });
        if (btnSdkAutoScroll) btnSdkAutoScroll.addEventListener('click', () => {
            sdkAutoScroll = !sdkAutoScroll;
            btnSdkAutoScroll.classList.toggle('active', sdkAutoScroll);
            if (sdkAutoScroll) {
                const activeContainer = sdkShowTimeline
                    ? document.getElementById('sdkTimeline')
                    : document.getElementById('sdkConversation');
                if (activeContainer) {
                    activeContainer.scrollTop = activeContainer.scrollHeight;
                }
            }
        });

        // SDK auto-scroll detection for Conversation view
        const sdkConvEl = document.getElementById('sdkConversation');
        if (sdkConvEl) sdkConvEl.addEventListener('scroll', () => {
            const isAtBottom = sdkConvEl.scrollHeight - sdkConvEl.scrollTop - sdkConvEl.clientHeight < 50;
            if (!isAtBottom && sdkAutoScroll) {
                sdkAutoScroll = false;
                if (btnSdkAutoScroll) btnSdkAutoScroll.classList.remove('active');
            }
        });

        // SDK auto-scroll detection for Timeline view
        const sdkTimeEl = document.getElementById('sdkTimeline');
        if (sdkTimeEl) sdkTimeEl.addEventListener('scroll', () => {
            const isAtBottom = sdkTimeEl.scrollHeight - sdkTimeEl.scrollTop - sdkTimeEl.clientHeight < 50;
            if (!isAtBottom && sdkAutoScroll) {
                sdkAutoScroll = false;
                if (btnSdkAutoScroll) btnSdkAutoScroll.classList.remove('active');
            }
        });

        try {
            const savedTab = localStorage.getItem('jeeves_viewer_main_tab');
            setMainTab(savedTab || 'sdk');
        } catch (e) {
            setMainTab('sdk');
        }
        
        // Connection handling
        function connect() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource('/api/stream');
            
            eventSource.onopen = () => {
                updateConnectionStatus(true);
                if (reconnectAttempts > 0) {
                    resyncLogs();
                }
                reconnectAttempts = 0;
            };
            
            eventSource.addEventListener('state', (event) => {
                try {
                    const state = JSON.parse(event.data);
                    updateState(state);
                } catch (e) {
                    console.error('Failed to parse state:', e);
                }
            });
            
            eventSource.addEventListener('logs', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.lines && data.lines.length > 0) {
                        appendLogs(data.lines);
                    }
                } catch (e) {
                    console.error('Failed to parse logs:', e);
                }
            });
            
            eventSource.addEventListener('heartbeat', () => {
                // Keep-alive received
            });

            // SDK SSE event handlers for real-time SDK output updates
            eventSource.addEventListener('sdk-init', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // Initialize or reset SDK output when a new session starts
                    // SSE events currently use v1-style data, so mark as v1
                    sdkOutput = {
                        schemaVersion: 'v1',
                        session_id: data.session_id,
                        status: data.status || 'running',
                        messages: [],
                        tool_calls: [],
                        stats: { message_count: 0, tool_call_count: 0 },
                        provider: null,  // v1 has no provider info
                    };
                    if (mainTab === 'sdk') renderSdkOutput();
                } catch (e) {
                    console.error('Failed to parse sdk-init:', e);
                }
            });

            eventSource.addEventListener('sdk-message', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (!sdkOutput) {
                        sdkOutput = { schemaVersion: 'v1', messages: [], tool_calls: [], stats: { message_count: 0, tool_call_count: 0 }, provider: null };
                    }
                    // Add the new message to the list
                    if (data.message) {
                        sdkOutput.messages.push(data.message);
                        sdkOutput.stats.message_count = sdkOutput.messages.length;
                    }
                    if (mainTab === 'sdk') renderSdkOutput();
                } catch (e) {
                    console.error('Failed to parse sdk-message:', e);
                }
            });

            eventSource.addEventListener('sdk-tool-start', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // Track tool start (we could show a pending indicator, but for now just log)
                    console.debug('Tool started:', data.name, data.tool_use_id);
                } catch (e) {
                    console.error('Failed to parse sdk-tool-start:', e);
                }
            });

            eventSource.addEventListener('sdk-tool-complete', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (!sdkOutput) {
                        sdkOutput = { schemaVersion: 'v1', messages: [], tool_calls: [], stats: { message_count: 0, tool_call_count: 0 }, provider: null };
                    }
                    // Add the completed tool call to the list
                    if (data.tool_use_id) {
                        sdkOutput.tool_calls.push({
                            name: data.name,
                            tool_use_id: data.tool_use_id,
                            duration_ms: data.duration_ms,
                            is_error: data.is_error
                        });
                        sdkOutput.stats.tool_call_count = sdkOutput.tool_calls.length;
                    }
                    if (mainTab === 'sdk') renderSdkOutput();
                } catch (e) {
                    console.error('Failed to parse sdk-tool-complete:', e);
                }
            });

            eventSource.addEventListener('sdk-complete', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (!sdkOutput) {
                        sdkOutput = { schemaVersion: 'v1', messages: [], tool_calls: [], stats: { message_count: 0, tool_call_count: 0 }, provider: null };
                    }
                    // Update session status and final stats
                    sdkOutput.success = data.status === 'success';
                    sdkOutput.status = data.status || 'success';
                    sdkOutput.error = data.status === 'error' ? 'Error' : null;
                    if (data.summary) {
                        sdkOutput.stats = { ...sdkOutput.stats, ...data.summary };
                    }
                    if (mainTab === 'sdk') renderSdkOutput();
                } catch (e) {
                    console.error('Failed to parse sdk-complete:', e);
                }
            });

            eventSource.onerror = () => {
                updateConnectionStatus(false);
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                setTimeout(connect, delay);
            };
        }
        
        function updateConnectionStatus(connected) {
            if (connected) {
                connectionDot.classList.add('connected');
                connectionText.textContent = 'Live';
            } else {
                connectionDot.classList.remove('connected');
                connectionText.textContent = 'Reconnecting...';
            }
        }
        
        function updateState(state) {
            currentState = state;
            
            const mode = state.mode;
            const status = state.status || {};
            const config = state.config || {};
            const run = state.run || {};
            
            // Update iteration
            if (state.iteration) {
                iterationBadge.style.display = 'flex';
                iterationNumber.textContent = state.iteration.current;
                iterationMax.textContent = state.iteration.max;
            } else {
                iterationBadge.style.display = 'none';
            }
            
            // Update status badge
            if (run.running) {
                setStatusBadge('running', 'Running');
            } else if (mode === 'unknown') {
                setStatusBadge('idle', 'Idle');
            } else if (status.phase === 'complete') {
                setStatusBadge('complete', 'Complete');
                // Notify on completion (only once)
                if (lastPhase && lastPhase !== 'complete') {
                    showNotification('Jeeves Complete!', 'All workflow phases have finished successfully.');
                }
            } else {
                setStatusBadge('idle', 'Ready');
            }
            
            // Track phase changes for notifications
            lastPhase = status.phase;
            
            // Update phase timeline
            if (mode === 'issue') {
                updatePhaseTimeline(status.phase || 'design_draft');
                if (checksCard) checksCard.style.display = 'none';
            } else if (mode === 'prd') {
                updatePRDProgress(status);
                if (checksCard) checksCard.style.display = 'none';
            } else {
                phaseTimeline.innerHTML = '<div class="empty-state"><div class="empty-title">No active workflow</div></div>';
                if (checksCard) checksCard.style.display = 'none';
            }
            
            // Update info grid
            updateInfoGrid(mode, status, config);

            // Prompt editor bootstrap (pick the currently-active prompt once).
            if (promptSelect || promptTabs) {
                const activePrompt = promptIdForState(state);
                const chooseAndLoad = (promptId) => {
                    if (promptLoadedId || promptDirty) return;
                    let id = promptId;
                    if (promptSelect) {
                        const hasOption = Array.from(promptSelect.options).some(o => o.value === id);
                        if (!hasOption) id = promptSelect.options[0] ? promptSelect.options[0].value : '';
                    } else if (Array.isArray(promptFiles) && promptFiles.length > 0) {
                        const has = promptFiles.some(p => p.id === id);
                        if (!has) id = promptFiles[0].id;
                    }
                    if (id) setCurrentPromptId(id, { confirmDiscard: false });
                };

                if (!promptListLoaded) loadPromptList().then(() => chooseAndLoad(activePrompt));
                else chooseAndLoad(activePrompt);
            }

            // Prefill init form from current state (only when empty).
            if (initIssueNumber && !initIssueNumber.value && status.issue_number) {
                initIssueNumber.value = String(status.issue_number);
            }
            if (initDesignDoc && !initDesignDoc.value && status.design_doc) {
                initDesignDoc.value = String(status.design_doc);
            }
            if (initBranch && !initBranch.value && status.branch_name) {
                initBranch.value = String(status.branch_name);
            }
            if (initRepo && !initRepo.value) {
                const repo = (config.issue && config.issue.repo) ? config.issue.repo : '';
                if (repo) initRepo.value = String(repo);
            }

            // Update logs from initial state
            if (state.recent_logs && state.recent_logs.length > 0 && allLogs.length === 0) {
                appendLogs(state.recent_logs);
            }

            updateRunControls(run);

            // Auto-switch sidebar to Monitor while running (reduces clutter).
            if (run.running && sidebarTab !== 'monitor') {
                setSidebarTab('monitor');
            }

            if (runPhase && status.phase) {
                // Check if the phase option exists in the dropdown
                const optionExists = Array.from(runPhase.options).some(opt => opt.value === status.phase);
                if (optionExists) {
                    runPhase.value = status.phase;
                }
            }
        }

        function updateRunControls(run) {
            if (!runStatusText) return;
            const running = !!run.running;
            runIsRunning = running;

            if (btnRun) btnRun.disabled = running;
            if (btnStop) btnStop.disabled = !running;

            if (running) {
                runStatusText.textContent = `Running (pid ${run.pid || '?'})\nStarted: ${run.started_at || ''}`;
            } else if (run.returncode !== null && run.returncode !== undefined) {
                runStatusText.textContent = `Not running\nLast exit code: ${run.returncode}`;
            } else {
                runStatusText.textContent = 'Not running';
            }
        }
        
        function setStatusBadge(type, text) {
            statusBadge.className = 'status-badge ' + type;
            statusBadge.textContent = text;
        }

        async function apiPost(path, body) {
            const response = await fetch(path, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body || {})
            });
            const data = await response.json().catch(() => null);
            return { response, data };
        }

        async function updateIssueStatus(phase) {
            const { response, data } = await apiPost('/api/issue/status', { phase: phase });
            if (!response.ok || !data || !data.ok) {
                const msg = (data && data.error) ? data.error : `Failed to update status (HTTP ${response.status})`;
                throw new Error(msg);
            }
            return data;
        }

        function promptIdForState(state) {
            if (!state) return null;
            if (state.mode === 'prd') return 'prompt.md';
            if (state.mode !== 'issue') return null;
            const phase = (state.status && state.status.phase) ? state.status.phase : 'implement';
            const map = {
                'design': 'issue.design.md',
                'implement': 'issue.implement.md',
                'review': 'issue.review.md'
            };
            return map[phase] || 'issue.implement.md';
        }

        function promptTabLabel(promptId) {
            if (!promptId) return '';
            if (promptId === 'prompt.md') return 'prd';
            let label = promptId;
            if (label.startsWith('issue.')) label = label.slice('issue.'.length);
            else if (label.startsWith('prompt.')) label = label.slice('prompt.'.length);
            if (label.endsWith('.md')) label = label.slice(0, -3);
            return label.replace(/\./g, ' / ');
        }

        function updatePromptTabsActive() {
            if (!promptTabs) return;
            const buttons = Array.from(promptTabs.querySelectorAll('[data-prompt-id]'));
            for (const btn of buttons) {
                const id = btn.getAttribute('data-prompt-id');
                btn.classList.toggle('active', !!promptLoadedId && id === promptLoadedId);
            }
        }

        function renderPromptTabs(prompts) {
            if (!promptTabs) return;
            promptTabs.innerHTML = '';
            for (const p of prompts) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'prompt-tab';
                btn.textContent = promptTabLabel(p.id);
                btn.setAttribute('data-prompt-id', p.id);
                btn.addEventListener('click', async () => {
                    await setCurrentPromptId(p.id, { confirmDiscard: true });
                });
                promptTabs.appendChild(btn);
            }
            updatePromptTabsActive();
        }

        async function setCurrentPromptId(promptId, { confirmDiscard = true } = {}) {
            if (!promptId) return;

            if (confirmDiscard && promptDirty && promptLoadedId && promptId !== promptLoadedId) {
                if (!confirm('Discard unsaved changes?')) {
                    if (promptSelect) promptSelect.value = promptLoadedId;
                    updatePromptTabsActive();
                    return;
                }
            }

            if (promptSelect) promptSelect.value = promptId;
            await loadPromptContent(promptId);
        }

        async function reloadPrompt() {
            const id = promptLoadedId || (promptSelect ? promptSelect.value : '');
            if (!id) return;
            if (promptDirty) {
                if (!confirm('Discard unsaved changes and reload?')) return;
            }
            await loadPromptContent(id);
        }

        async function loadPromptList() {
            if (!promptSelect && !promptTabs) return;
            if (promptListLoaded) return;
            if (promptListPromise) return promptListPromise;

            promptListPromise = (async () => {
                const response = await fetch('/api/prompts', { cache: 'no-store' });
                const data = await response.json().catch(() => null);
                if (!response.ok || !data || !data.ok) {
                    throw new Error('Failed to load prompt list');
                }

                const prompts = Array.isArray(data.prompts) ? data.prompts : [];
                promptFiles = prompts;
                if (promptSelect) {
                    const previous = promptSelect.value || promptLoadedId;
                    promptSelect.innerHTML = '';
                    for (const p of prompts) {
                        const opt = document.createElement('option');
                        opt.value = p.id;
                        opt.textContent = p.name;
                        promptSelect.appendChild(opt);
                    }
                    if (previous) promptSelect.value = previous;
                }
                renderPromptTabs(prompts);
                promptListLoaded = true;
            })()
                .catch((e) => {
                    promptListPromise = null;
                    if (promptStatusText) promptStatusText.textContent = String(e);
                });

            return promptListPromise;
        }

        async function loadPromptContent(promptId) {
            if (!promptEditor || !promptId) return;
            const response = await fetch('/api/prompts/' + encodeURIComponent(promptId), { cache: 'no-store' });
            const data = await response.json().catch(() => null);
            if (!response.ok || !data || !data.ok) {
                const msg = (data && data.error) ? data.error : `Failed to load prompt (HTTP ${response.status})`;
                if (promptStatusText) promptStatusText.textContent = msg;
                return;
            }
            promptLoadedId = promptId;
            if (promptSelect) promptSelect.value = promptId;
            promptEditor.value = (data.prompt && typeof data.prompt.content === 'string') ? data.prompt.content : '';
            promptDirty = false;
            if (promptStatusText) promptStatusText.textContent = `Loaded ${promptId}`;
            updatePromptTabsActive();
        }

        async function savePromptContent() {
            if (!promptLoadedId || !promptEditor) return;
            if (btnPromptSave) btnPromptSave.disabled = true;
            try {
                const { response, data } = await apiPost('/api/prompts/' + encodeURIComponent(promptLoadedId), { content: promptEditor.value });
                if (!response.ok || !data || !data.ok) {
                    const msg = (data && data.error) ? data.error : `Failed to save (HTTP ${response.status})`;
                    if (promptStatusText) promptStatusText.textContent = msg;
                    return;
                }
                promptDirty = false;
                if (promptStatusText) promptStatusText.textContent = `Saved ${promptLoadedId}`;
            } finally {
                if (btnPromptSave) btnPromptSave.disabled = false;
            }
        }

        async function initIssue() {
            if (btnInitIssue) btnInitIssue.disabled = true;
            if (initStatusText) initStatusText.textContent = 'Running init-issue.sh...';
            try {
                const { response, data } = await apiPost('/api/init/issue', {
                    issue: initIssueNumber ? initIssueNumber.value : '',
                    design_doc: initDesignDoc ? initDesignDoc.value : '',
                    repo: initRepo ? initRepo.value : '',
                    branch: initBranch ? initBranch.value : '',
                    force: initForce ? !!initForce.checked : false
                });

                if (!response.ok || !data || !data.ok) {
                    const msg = (data && data.output) ? data.output : ((data && data.error) ? data.error : `Init failed (HTTP ${response.status})`);
                    if (initStatusText) initStatusText.textContent = msg;
                    return;
                }

                if (initStatusText) initStatusText.textContent = (data.output || 'Init complete.');

                // Refresh workflow phases for the new issue
                await fetchWorkflow();
            } catch (e) {
                if (initStatusText) initStatusText.textContent = 'Init failed: ' + e;
            } finally {
                if (btnInitIssue) btnInitIssue.disabled = false;
            }
        }

        if (btnRun) {
            btnRun.addEventListener('click', async () => {
                btnRun.disabled = true;
                try {
                    // max_iterations controls fresh-context iteration loop
                    const maxIterations = runMaxTurns ? parseInt(runMaxTurns.value || '10', 10) : 10;

                    const { response, data } = await apiPost('/api/run', {
                        max_iterations: Number.isFinite(maxIterations) ? maxIterations : 10
                    });

                    if (!response.ok) {
                        const msg = (data && data.error) ? data.error : `Failed to start (HTTP ${response.status})`;
                        alert(msg);
                        return;
                    }
                } catch (e) {
                    alert('Failed to start: ' + e);
                } finally {
                    btnRun.disabled = false;
                }
            });
        }

        if (runPhase) {
            runPhase.addEventListener('change', async () => {
                if (runIsRunning) return;
                const phase = runPhase.value;
                try {
                    await updateIssueStatus(phase);
                } catch (e) {
                    alert((e && e.message) ? e.message : String(e));
                }
            });
        }

        if (btnStop) {
            btnStop.addEventListener('click', async () => {
                btnStop.disabled = true;
                try {
                    const { response, data } = await apiPost('/api/run/stop', {});
                    if (!response.ok) {
                        const msg = (data && data.error) ? data.error : `Failed to stop (HTTP ${response.status})`;
                        alert(msg);
                        return;
                    }
                } catch (e) {
                    alert('Failed to stop: ' + e);
                } finally {
                    btnStop.disabled = false;
                }
            });
        }

        if (promptSelect) {
            promptSelect.addEventListener('change', async () => {
                const id = promptSelect.value;
                await setCurrentPromptId(id, { confirmDiscard: true });
            });
        }

        if (promptEditor) {
            promptEditor.addEventListener('input', () => {
                promptDirty = true;
                if (promptStatusText && promptLoadedId) {
                    promptStatusText.textContent = `Editing ${promptLoadedId} (unsaved)`;
                }
            });
        }

        if (btnPromptReload) {
            btnPromptReload.addEventListener('click', async () => {
                await reloadPrompt();
            });
        }

        if (btnPromptSave) {
            btnPromptSave.addEventListener('click', async () => {
                await savePromptContent();
            });
        }

        if (btnInitIssue) {
            btnInitIssue.addEventListener('click', async () => {
                await initIssue();
            });
        }
        
        function updatePhaseTimeline(currentPhase) {
            const currentIndex = getPhaseIndex(currentPhase);

            phaseTimeline.innerHTML = phases.map((phase, index) => {
                const phaseIdx = getPhaseIndex(phase.id);
                let stateClass = '';
                let icon = '';

                if (phaseIdx < currentIndex || currentPhase === 'complete') {
                    stateClass = 'complete';
                    icon = '&#10003;';
                } else if (phase.id === currentPhase) {
                    stateClass = 'active';
                    icon = '&#9679;';
                }

                return `
                    <div class="phase-item ${stateClass}">
                        <div class="phase-dot">${icon}</div>
                        <div class="phase-content">
                            <div class="phase-name">${phase.name}</div>
                            <div class="phase-desc">${phase.desc}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updatePRDProgress(status) {
            const total = status.total_stories || 0;
            const passing = status.passing_stories || 0;
            const percent = total > 0 ? Math.round((passing / total) * 100) : 0;
            
            phaseTimeline.innerHTML = `
                <div class="progress-section">
                    <div class="progress-header">
                        <span>Stories Progress</span>
                        <span>${passing} / ${total} (${percent}%)</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${percent}%"></div>
                    </div>
                </div>
                ${status.stories ? `
                    <div style="margin-top: 16px;">
                        ${status.stories.map(s => `
                            <div style="display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-color);">
                                <span style="color: ${s.passes ? 'var(--accent-green)' : 'var(--text-muted)'};">${s.passes ? '&#10003;' : '&#9675;'}</span>
                                <span style="font-size: 13px;">${escapeHtml(s.title)}</span>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
        }
        
        function updateInfoGrid(mode, status, config) {
            let items = [];
            
            items.push({ label: 'Mode', value: mode.charAt(0).toUpperCase() + mode.slice(1) });
            
            if (mode === 'issue') {
                if (status.issue_number) {
                    const url = status.issue_url || `#${status.issue_number}`;
                    items.push({ 
                        label: 'Issue', 
                        value: `<a href="${escapeHtml(status.issue_url || '#')}" target="_blank">#${status.issue_number}</a>`
                    });
                }
                
                if (status.branch_name) {
                    items.push({ label: 'Branch', value: escapeHtml(status.branch_name) });
                }
                
                if (status.design_doc) {
                    items.push({ label: 'Design Doc', value: escapeHtml(status.design_doc.split('/').pop()) });
                }
                
                items.push({ label: 'Phase', value: formatPhase(status.phase) });
            } else if (mode === 'prd') {
                items.push({ label: 'Stories', value: `${status.passing_stories || 0} / ${status.total_stories || 0}` });
            }
            
            infoGrid.innerHTML = items.map(item => `
                <div class="info-row">
                    <span class="info-label">${item.label}</span>
                    <span class="info-value">${item.value}</span>
                </div>
            `).join('');
        }
        
        function formatPhase(phase) {
            const names = {
                'design': 'Design',
                'implement': 'Implement',
                'review': 'Review',
                'complete': 'Complete'
            };
            return names[phase] || phase;
        }
        
        function updateStatusChecks(status) {
            if (!statusChecks) return;
            statusChecks.innerHTML = '';
        }
        
        // Log handling
        const diffState = { inDiff: false };

        function updateLogCount(count) {
            logCount.textContent = `${count} lines`;
        }

        function isDiffStartLine(line) {
            return line.startsWith('diff --git ') || line.startsWith('--- a/') || line.startsWith('+++ b/');
        }

        function isDiffMetaLine(line) {
            return (
                line.startsWith('diff --git ') ||
                line.startsWith('index ') ||
                line.startsWith('--- ') ||
                line.startsWith('+++ ') ||
                line.startsWith('@@ ') ||
                line.startsWith('new file mode ') ||
                line.startsWith('deleted file mode ') ||
                line.startsWith('similarity index ') ||
                line.startsWith('rename from ') ||
                line.startsWith('rename to ') ||
                line.startsWith('copy from ') ||
                line.startsWith('copy to ') ||
                line.startsWith('Binary files ') ||
                line.startsWith('\\ No newline at end of file')
            );
        }

        function isDiffContentLine(line) {
            return line.startsWith('+') || line.startsWith('-') || line.startsWith(' ') || line.startsWith('\\');
        }

        function getLogClassForLine(line) {
            if (line === '') {
                diffState.inDiff = false;
                return '';
            }

            if (isDiffStartLine(line)) {
                diffState.inDiff = true;
                if (line.startsWith('diff --git ')) return 'diff-header';
                return 'diff-file';
            }

            if (diffState.inDiff) {
                if (!(isDiffMetaLine(line) || isDiffContentLine(line))) {
                    diffState.inDiff = false;
                }
            }

            if (diffState.inDiff) {
                if (line.startsWith('@@ ')) return 'diff-hunk';
                if (line.startsWith('index ')) return 'diff-meta';
                if (line.startsWith('--- ') || line.startsWith('+++ ')) return 'diff-file';
                if (line.startsWith('+') && !line.startsWith('+++ ')) return 'diff-add';
                if (line.startsWith('-') && !line.startsWith('--- ')) return 'diff-del';
                if (line.startsWith(' ')) return 'diff-context';
                return 'diff-meta';
            }

            if (line === 'thinking' || line === 'exec') return 'section';
            if (/^file update:?$/i.test(line)) return 'section';
            if (line.startsWith('Plan update')) return 'section';
            if (line.startsWith('/bin/bash -lc ')) return 'command';
            if (/^apply_patch\(/.test(line)) return 'command';

            if (/\[ERROR\]|Error:|error:/i.test(line)) return 'error';
            if (/\[WARN\]|Warning:|warn:/i.test(line)) return 'warn';
            if (/\[INFO\]/i.test(line)) return 'info';
            if (/\[DEBUG\]/i.test(line)) return 'debug';
            if (/Jeeves Iteration \d+ of \d+/i.test(line)) return 'iteration';
            if (/completed|success|passed|✓|✔/i.test(line)) return 'success';
            return '';
        }

        function ensureLogContainerReady() {
            if (logContent.dataset.empty === '1') {
                logContent.innerHTML = '';
                logContent.dataset.empty = '0';
            }
        }

        function appendLogLinesToDom(lines) {
            ensureLogContainerReady();

            const fragment = document.createDocumentFragment();
            for (const line of lines) {
                const className = getLogClassForLine(line);
                const div = document.createElement('div');
                div.className = `log-line ${className}`;
                div.textContent = line;
                fragment.appendChild(div);
            }
            logContent.appendChild(fragment);

            while (logContent.childElementCount > MAX_LOGS) {
                logContent.removeChild(logContent.firstElementChild);
            }

            updateLogCount(allLogs.length);
            if (autoScroll) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        }

        function appendLogs(lines) {
            const newLines = [];
            for (const line of lines) {
                if (allLogs.length >= MAX_LOGS) {
                    allLogs.shift();
                }
                allLogs.push(line);
                newLines.push(line);
            }

            if (!searchFilter && !hideDiffs) {
                appendLogLinesToDom(newLines);
                return;
            }

            scheduleRender();
        }

        function renderLogs() {
            const filterLower = searchFilter ? searchFilter.toLowerCase() : '';

            diffState.inDiff = false;
            const rendered = [];

            const hiddenDiff = {
                inDiff: false,
                placeholderEmitted: false,
                pendingFileUpdate: false,
            };

            function parseDiffHeaderPath(line) {
                const match = line.match(/^diff --git a\/(.+?) b\/(.+)$/);
                if (!match) return null;
                return match[1] || null;
            }

            function isDiffStartLine(line) {
                return line.startsWith('diff --git ') || line.startsWith('--- a/') || line.startsWith('+++ b/');
            }

            function isDiffContinuationLine(line) {
                return (
                    line === '' ||
                    line.startsWith('index ') ||
                    line.startsWith('@@ ') ||
                    line.startsWith('--- ') ||
                    line.startsWith('+++ ') ||
                    line.startsWith('+') ||
                    line.startsWith('-') ||
                    line.startsWith(' ') ||
                    line.startsWith('\\')
                );
            }

            function pushRendered(line, className) {
                if (filterLower && !line.toLowerCase().includes(filterLower)) return;
                rendered.push({ line, className });
            }

            for (const line of allLogs) {
                if (hideDiffs) {
                    if (/^file update:?$/i.test(line)) {
                        hiddenDiff.inDiff = true;
                        hiddenDiff.placeholderEmitted = false;
                        hiddenDiff.pendingFileUpdate = true;
                        continue;
                    }

                    if (hiddenDiff.inDiff) {
                        if (line.startsWith('diff --git ')) {
                            if (!hiddenDiff.placeholderEmitted) {
                                const path = parseDiffHeaderPath(line);
                                const placeholder = path ? `file update (diff hidden): ${path}` : 'file update (diff hidden)';
                                pushRendered(placeholder, 'section');
                                hiddenDiff.placeholderEmitted = true;
                            }
                            continue;
                        }

                        if (isDiffStartLine(line) || isDiffContinuationLine(line)) {
                            continue;
                        }

                        if (hiddenDiff.pendingFileUpdate && !hiddenDiff.placeholderEmitted) {
                            pushRendered('file update (diff hidden)', 'section');
                        }

                        hiddenDiff.inDiff = false;
                        hiddenDiff.placeholderEmitted = false;
                        hiddenDiff.pendingFileUpdate = false;
                        // fall through to handle the current line normally
                    }

                    if (isDiffStartLine(line)) {
                        const path = line.startsWith('diff --git ') ? parseDiffHeaderPath(line) : null;
                        const placeholder = path ? `diff (hidden): ${path}` : 'diff (hidden)';
                        pushRendered(placeholder, 'section');
                        hiddenDiff.inDiff = true;
                        hiddenDiff.placeholderEmitted = true;
                        hiddenDiff.pendingFileUpdate = false;
                        continue;
                    }
                }

                const className = getLogClassForLine(line);
                pushRendered(line, className);
            }

            if (hideDiffs && hiddenDiff.inDiff && hiddenDiff.pendingFileUpdate && !hiddenDiff.placeholderEmitted) {
                pushRendered('file update (diff hidden)', 'section');
            }

            updateLogCount(rendered.length);

            if (rendered.length === 0) {
                logContent.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128196;</div>
                        <div>${searchFilter ? 'No matching logs' : 'Waiting for logs...'}</div>
                    </div>
                `;
                logContent.dataset.empty = '1';
                return;
            }

            logContent.dataset.empty = '0';
            const html = rendered
                .map(({ line, className }) => `<div class="log-line ${className}">${escapeHtml(line)}</div>`)
                .join('');

            logContent.innerHTML = html;

            if (autoScroll) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Event handlers
        btnAutoScroll.addEventListener('click', () => {
            autoScroll = !autoScroll;
            btnAutoScroll.classList.toggle('active', autoScroll);
            if (autoScroll) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        });
        
        btnClear.addEventListener('click', () => {
            allLogs = [];
            renderLogs();
        });

        if (btnHideDiffs) btnHideDiffs.addEventListener('click', () => {
            hideDiffs = !hideDiffs;
            try {
                localStorage.setItem('jeeves_viewer_hide_diffs', hideDiffs ? '1' : '0');
            } catch (e) {
                // ignore
            }
            updateHideDiffsButton();
            scheduleRender();
        });
        
        searchInput.addEventListener('input', (e) => {
            searchFilter = e.target.value;
            renderLogs();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                if (mainTab === 'prompts' && promptEditor) {
                    promptEditor.focus();
                } else if (searchInput) {
                    searchInput.focus();
                }
            }
            if (e.key === 'Escape') {
                if (mainTab === 'logs' && searchInput) {
                    searchInput.value = '';
                    searchFilter = '';
                    renderLogs();
                    searchInput.blur();
                } else if (promptEditor) {
                    promptEditor.blur();
                }
            }
            if (e.key === 'End') {
                if (mainTab === 'logs') {
                    logContent.scrollTop = logContent.scrollHeight;
                } else if (mainTab === 'sdk') {
                    const activeContainer = sdkShowTimeline
                        ? document.getElementById('sdkTimeline')
                        : document.getElementById('sdkConversation');
                    if (activeContainer) {
                        activeContainer.scrollTop = activeContainer.scrollHeight;
                    }
                }
            }
        });
        
        // Detect manual scroll
        logContent.addEventListener('scroll', () => {
            const isAtBottom = logContent.scrollHeight - logContent.scrollTop - logContent.clientHeight < 50;
            if (!isAtBottom && autoScroll) {
                autoScroll = false;
                btnAutoScroll.classList.remove('active');
            }
        });
        
        // Start
        fetchWorkflow();
        loadPromptList();
        connect();
    </script>
</body>
</html>
