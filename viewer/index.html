<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeeves Viewer</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --border-active: #58a6ff;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
            --accent-orange: #db6d28;
            --phase-design: #a371f7;
            --phase-implement: #d29922;
            --phase-review: #db6d28;
            --phase-coverage: #f85149;
            --phase-sonar: #3fb950;
            --phase-complete: #58a6ff;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
        }
        
        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 24px;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .brand-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .brand-text {
            font-size: 18px;
            font-weight: 600;
        }
        
        .header-status {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .connection-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
        }
        
        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            transition: background 0.3s;
        }
        
        .connection-dot.connected {
            background: var(--accent-green);
            box-shadow: 0 0 8px var(--accent-green);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-badge.running {
            background: rgba(63, 185, 80, 0.15);
            color: var(--accent-green);
            border: 1px solid var(--accent-green);
        }
        
        .status-badge.complete {
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent-blue);
            border: 1px solid var(--accent-blue);
        }
        
        .status-badge.idle {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        /* Main Layout */
        .main {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
            min-height: calc(100vh - 60px);
        }
        
        @media (max-width: 1000px) {
            .main {
                grid-template-columns: 1fr;
            }
        }
        
        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .card-header {
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }
        
        .card-body {
            padding: 16px;
        }
        
        /* Phase Timeline */
        .phase-timeline {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .phase-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            position: relative;
        }
        
        .phase-item:not(:last-child)::after {
            content: '';
            position: absolute;
            left: 11px;
            top: 36px;
            bottom: -12px;
            width: 2px;
            background: var(--border-color);
        }
        
        .phase-item.active::after {
            background: var(--accent-blue);
        }
        
        .phase-item.complete::after {
            background: var(--accent-green);
        }
        
        .phase-dot {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .phase-item.complete .phase-dot {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }
        
        .phase-item.active .phase-dot {
            border-color: var(--accent-blue);
            background: var(--accent-blue);
            color: white;
            animation: phase-pulse 1.5s infinite;
        }
        
        @keyframes phase-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(88, 166, 255, 0); }
        }
        
        .phase-content {
            flex: 1;
            min-width: 0;
        }
        
        .phase-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .phase-item.active .phase-name,
        .phase-item.complete .phase-name {
            color: var(--text-primary);
        }
        
        .phase-desc {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        /* Info Grid */
        .info-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        
        .info-label {
            color: var(--text-secondary);
        }
        
        .info-value {
            font-weight: 500;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }
        
        .info-value a {
            color: var(--accent-blue);
            text-decoration: none;
        }
        
        .info-value a:hover {
            text-decoration: underline;
        }
        
        /* Progress Bar */
        .progress-section {
            margin-top: 16px;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .progress-bar {
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-blue));
            border-radius: 4px;
            transition: width 0.5s ease-out;
        }
        
        /* Status Checks */
        .status-checks {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .status-check {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid transparent;
            border-radius: 8px;
            font-size: 12px;
        }

        button.status-check {
            appearance: none;
            color: inherit;
            text-align: left;
            width: 100%;
        }

        .status-check.toggleable {
            cursor: pointer;
        }

        .status-check.toggleable:hover {
            border-color: var(--border-active);
        }

        .status-check.toggleable:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .check-icon {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .check-icon.pass {
            background: var(--accent-green);
        }
        
        .check-icon.fail {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
        }
        
        .check-icon.pending {
            background: var(--bg-primary);
            border: 2px solid var(--accent-yellow);
        }
        
        /* Log Panel */
        .log-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
            height: calc(100vh - 108px);
        }
        
        .log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .panel-left {
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 0;
        }

        .panel-tabs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tab-btn {
            padding: 6px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--text-muted);
        }

        .tab-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .log-title {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .log-count {
            background: var(--bg-primary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .log-controls {
            display: flex;
            gap: 8px;
        }
        
        .log-btn {
            padding: 6px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .log-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
        }
        
        .log-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .log-body {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .log-content {
            flex: 1;
            overflow: auto;
            padding: 16px;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.6;
            background: var(--bg-primary);
        }
        
        .log-content::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        .log-content::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }
        
        .log-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
            border: 2px solid var(--bg-primary);
        }
        
        .log-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Prompt Editor Panel (tab) */
        .prompt-panel {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
        }

        .prompt-toolbar {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .prompt-file {
            flex: 1;
            min-width: 260px;
        }

        .prompt-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .prompt-tab {
            padding: 4px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .prompt-tab:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
        }

        .prompt-tab.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .prompt-editor {
            flex: 1;
            min-height: 0;
            resize: none;
        }

        /* SDK Output Panel */
        .sdk-panel {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
        }

        .sdk-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .sdk-stats {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .sdk-stat {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .sdk-stat-label {
            color: var(--text-muted);
        }

        .sdk-status-success {
            color: var(--accent-green);
            font-weight: 600;
        }

        .sdk-status-error {
            color: var(--accent-red);
            font-weight: 600;
        }

        .sdk-status-pending {
            color: var(--text-muted);
        }

        .sdk-controls {
            display: flex;
            gap: 8px;
        }

        .sdk-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sdk-conversation {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 8px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
        }

        .sdk-message {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid transparent;
        }

        .sdk-message.system {
            background: rgba(163, 113, 247, 0.1);
            border-left-color: var(--accent-purple);
        }

        .sdk-message.user {
            background: rgba(88, 166, 255, 0.1);
            border-left-color: var(--accent-blue);
        }

        .sdk-message.assistant {
            background: rgba(63, 185, 80, 0.08);
            border-left-color: var(--accent-green);
        }

        .sdk-message.tool_result {
            background: rgba(219, 109, 40, 0.1);
            border-left-color: var(--accent-orange);
            font-size: 11px;
        }

        .sdk-message.result {
            background: rgba(88, 166, 255, 0.15);
            border-left-color: var(--accent-blue);
            border-width: 4px;
        }

        .sdk-message-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .sdk-message-type {
            font-weight: 600;
            text-transform: uppercase;
        }

        .sdk-message-content {
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-primary);
        }

        .sdk-tool-use {
            margin-top: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 11px;
        }

        .sdk-tool-name {
            color: var(--accent-yellow);
            font-weight: 600;
        }

        .sdk-tool-input {
            margin-top: 4px;
            color: var(--text-secondary);
            max-height: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sdk-timeline {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 8px;
        }

        .sdk-timeline-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            margin-bottom: 4px;
            background: var(--bg-secondary);
            border-radius: 6px;
        }

        .sdk-timeline-bar {
            width: 100px;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
        }

        .sdk-timeline-fill {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 3px;
        }

        .sdk-timeline-name {
            flex: 1;
            font-size: 12px;
            color: var(--text-primary);
        }

        .sdk-timeline-duration {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .log-line {
            padding: 2px 8px;
            margin: 1px 0;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .log-line:hover {
            background: rgba(255, 255, 255, 0.03);
        }
        
        .log-line.error {
            color: var(--accent-red);
            background: rgba(248, 81, 73, 0.1);
        }
        
        .log-line.warn {
            color: var(--accent-yellow);
        }
        
        .log-line.success {
            color: var(--accent-green);
        }
        
        .log-line.info {
            color: var(--accent-blue);
        }
        
        .log-line.debug {
            color: var(--text-muted);
        }
        
        .log-line.iteration {
            color: var(--accent-purple);
            font-weight: 600;
            background: rgba(163, 113, 247, 0.1);
            margin: 8px 0;
            padding: 8px 12px;
        }

        /* Codex sections */
        .log-line.section {
            color: var(--text-secondary);
            background: rgba(139, 148, 158, 0.08);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .log-line.command {
            color: var(--accent-blue);
        }

        /* Diff styling (GitHub-ish) */
        .log-line.diff-header,
        .log-line.diff-meta,
        .log-line.diff-file,
        .log-line.diff-hunk,
        .log-line.diff-add,
        .log-line.diff-del,
        .log-line.diff-context {
            white-space: pre;
            word-break: normal;
        }

        .log-line.diff-header {
            color: var(--text-secondary);
            background: rgba(139, 148, 158, 0.06);
            font-weight: 600;
            margin-top: 6px;
        }

        .log-line.diff-meta {
            color: var(--text-muted);
        }

        .log-line.diff-file {
            color: var(--accent-blue);
            font-weight: 600;
        }

        .log-line.diff-hunk {
            color: var(--accent-purple);
            background: rgba(163, 113, 247, 0.06);
        }

        .log-line.diff-add {
            color: var(--accent-green);
            background: rgba(63, 185, 80, 0.12);
        }

        .log-line.diff-del {
            color: var(--accent-red);
            background: rgba(248, 81, 73, 0.12);
        }

        .log-line.diff-context {
            color: var(--text-primary);
        }
        
        .log-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: var(--text-muted);
        }
        
        .log-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        /* Search */
        .search-container {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .search-input:focus {
            border-color: var(--accent-blue);
        }
        
        .search-input::placeholder {
            color: var(--text-muted);
        }

        /* Controls */
        .control-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
        }

        .control-label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .control-input,
        .control-textarea {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }

        .control-input:focus,
        .control-textarea:focus {
            border-color: var(--accent-blue);
        }

        .control-textarea {
            resize: vertical;
            min-height: 70px;
            font-family: inherit;
        }

        .editor-textarea {
            min-height: 240px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .control-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .control-status {
            margin-top: 10px;
            font-size: 12px;
            color: var(--text-muted);
            line-height: 1.4;
            white-space: pre-line;
        }

        /* Iteration indicator */
        .iteration-badge {
            background: var(--bg-tertiary);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .iteration-badge .number {
            font-weight: 700;
            font-size: 20px;
            color: var(--accent-purple);
        }
        
        .iteration-badge .label {
            color: var(--text-secondary);
        }
        
        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 48px 24px;
            text-align: center;
        }
        
        .empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .empty-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .empty-desc {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        /* Keyboard hint */
        .keyboard-hint {
            position: fixed;
            bottom: 16px;
            right: 16px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .keyboard-hint kbd {
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-family: inherit;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="brand">
                <div class="brand-icon">R</div>
                <span class="brand-text">Jeeves Viewer</span>
            </div>
            <div class="header-status">
                <div class="iteration-badge" id="iterationBadge" style="display: none;">
                    <span class="number" id="iterationNumber">1</span>
                    <span class="label">of <span id="iterationMax">10</span></span>
                </div>
                <div class="connection-indicator">
                    <span class="connection-dot" id="connectionDot"></span>
                    <span id="connectionText">Connecting...</span>
                </div>
                <span class="status-badge idle" id="statusBadge">Idle</span>
            </div>
        </div>
    </header>
    
    <main class="main">
        <aside class="sidebar">
            <div class="panel-tabs">
                <button class="tab-btn active" id="sidebarTabSetup">Setup</button>
                <button class="tab-btn" id="sidebarTabMonitor">Monitor</button>
            </div>

            <div id="sidebarSetupSection">
            <!-- Controls -->
            <div class="card">
                <div class="card-header">Controls</div>
                <div class="card-body">
                    <div class="control-row">
                        <div class="control-label">Runner</div>
                        <select class="control-input" id="runRunner">
                            <option value="auto">Auto-detect</option>
                            <option value="codex">Codex</option>
                            <option value="claude">Claude</option>
                            <option value="opencode">Opencode</option>
                        </select>
                    </div>
                    <div class="control-row">
                        <div class="control-label">Max iterations</div>
                        <input class="control-input" id="runMaxIterations" type="number" min="1" max="10000" value="10" />
                    </div>
                    <div class="control-row">
                        <div class="control-label">Review passes required</div>
                        <input class="control-input" id="configReviewPasses" type="number" min="1" max="10" value="3" />
                    </div>
                    <div class="control-row">
                        <label class="control-label"><input type="checkbox" id="configAutoSkipTaskReviews" /> Auto-skip low-risk task reviews</label>
                    </div>
                    <div class="control-actions">
                        <button class="log-btn active" id="btnRun">Run</button>
                    </div>
                </div>
            </div>

            <!-- Git -->
            <div class="card">
                <div class="card-header">Git</div>
                <div class="card-body">
                    <div class="control-row">
                        <div class="control-label">Branch</div>
                        <input class="control-input" id="gitBranch" type="text" value="main" />
                    </div>
                    <div class="control-actions">
                        <button class="log-btn active" id="btnGitUpdateMain">Checkout &amp; Update</button>
                    </div>
                    <div class="control-status" id="gitStatusText"></div>
                </div>
            </div>

            <!-- Init Issue -->
            <div class="card">
                <div class="card-header">Init Issue</div>
                <div class="card-body">
                    <div class="control-row">
                        <div class="control-label">Issue (number or URL)</div>
                        <input class="control-input" id="initIssueNumber" type="text" placeholder="e.g. 590 or https://github.com/org/repo/issues/590" />
                    </div>
                    <div class="control-row">
                        <div class="control-label">Design doc (optional)</div>
                        <input class="control-input" id="initDesignDoc" type="text" placeholder="e.g. docs/issue-590-design.md" />
                    </div>
                    <div class="control-row">
                        <div class="control-label">Repo (optional)</div>
                        <input class="control-input" id="initRepo" type="text" placeholder="e.g. owner/repo" />
                    </div>
                    <div class="control-row">
                        <div class="control-label">Branch (optional)</div>
                        <input class="control-input" id="initBranch" type="text" placeholder="e.g. issue/590-some-slug" />
                    </div>
                    <div class="control-row">
                        <label class="control-label"><input type="checkbox" id="initForce" /> Force overwrite</label>
                    </div>
                    <div class="control-actions">
                        <button class="log-btn active" id="btnInitIssue">Init</button>
                    </div>
                    <div class="control-status" id="initStatusText"></div>
                </div>
            </div>
            </div>

            <div id="sidebarMonitorSection" style="display: none;">
            <div class="card">
                <div class="card-header">Run</div>
                <div class="card-body">
                    <div class="control-actions">
                        <button class="log-btn" id="btnStop">Stop</button>
                    </div>
                    <div class="control-status" id="runStatusText"></div>
                </div>
            </div>

            <!-- Phase Progress -->
            <div class="card">
                <div class="card-header">Workflow Progress</div>
                <div class="card-body">
                    <div class="phase-timeline" id="phaseTimeline">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
            
            <!-- Status Info -->
            <div class="card">
                <div class="card-header">Details</div>
                <div class="card-body">
                    <div class="info-grid" id="infoGrid">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Status Checks -->
            <div class="card" id="checksCard">
                <div class="card-header">Status Checks</div>
                <div class="card-body">
                    <div class="status-checks" id="statusChecks">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
            </div>
        </aside>
        
        <section class="card log-panel">
            <div class="log-header">
                <div class="panel-left">
                    <div class="panel-tabs">
                        <button class="tab-btn active" id="tabLogs">Logs</button>
                        <button class="tab-btn" id="tabSdk">SDK</button>
                        <button class="tab-btn" id="tabPrompts">Prompts</button>
                    </div>
                    <span class="log-count" id="logCount">0 lines</span>
                </div>
                <div class="log-controls" id="logControls">
                    <button class="log-btn" id="btnClear">Clear</button>
                    <button class="log-btn" id="btnHideDiffs">Hide diffs</button>
                    <button class="log-btn active" id="btnAutoScroll">Auto-scroll</button>
                </div>
            </div>
            <div class="search-container" id="logsSearchContainer">
                <input type="text" class="search-input" id="searchInput" placeholder="Filter logs... (Ctrl+F)">
            </div>
            <div class="log-body" id="logsBody">
                <div class="log-content" id="logContent">
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128196;</div>
                        <div>Waiting for logs...</div>
                    </div>
                </div>
            </div>
            <div class="prompt-panel" id="promptsBody" style="display: none;">
                <div class="prompt-toolbar">
                    <div class="prompt-file">
                        <div class="control-label">Prompt file</div>
                        <select class="control-input" id="promptSelect"></select>
                        <div class="prompt-tabs" id="promptTabs"></div>
                    </div>
                    <div class="control-actions">
                        <button class="log-btn" id="btnPromptReload">Reload</button>
                        <button class="log-btn active" id="btnPromptSave">Save</button>
                    </div>
                </div>
                <textarea class="control-textarea editor-textarea prompt-editor" id="promptEditor" placeholder="Select a prompt file..."></textarea>
                <div class="control-status" id="promptStatusText"></div>
            </div>
            <div class="sdk-panel" id="sdkBody" style="display: none;">
                <div class="sdk-toolbar">
                    <div class="sdk-stats" id="sdkStats">
                        <span class="sdk-stat"><span class="sdk-stat-label">Session:</span> <span id="sdkSessionId">-</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Messages:</span> <span id="sdkMessageCount">0</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Tool calls:</span> <span id="sdkToolCount">0</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Duration:</span> <span id="sdkDuration">-</span></span>
                        <span class="sdk-stat"><span class="sdk-stat-label">Status:</span> <span id="sdkStatus" class="sdk-status-pending">-</span></span>
                    </div>
                    <div class="sdk-controls">
                        <button class="log-btn" id="btnSdkRefresh">Refresh</button>
                        <button class="log-btn" id="btnSdkTimeline">Timeline</button>
                    </div>
                </div>
                <div class="sdk-content" id="sdkContent">
                    <div class="sdk-conversation" id="sdkConversation">
                        <div class="log-empty">
                            <div class="log-empty-icon">&#128172;</div>
                            <div>No SDK output available</div>
                            <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Run with --runner sdk to see structured output</div>
                        </div>
                    </div>
                    <div class="sdk-timeline" id="sdkTimeline" style="display: none;"></div>
                </div>
            </div>
        </section>
    </main>
    
    <div class="keyboard-hint">
        <kbd>Ctrl</kbd>+<kbd>F</kbd> Filter &nbsp; <kbd>Esc</kbd> Clear filter &nbsp; <kbd>End</kbd> Jump to bottom
    </div>

    <script>
        // State
        let eventSource = null;
        let currentState = null;
        let allLogs = [];
        let autoScroll = true;
        let searchFilter = '';
        let hideDiffs = false;
        let reconnectAttempts = 0;
        let lastPhase = null;
        let notificationsEnabled = false;
        let renderScheduled = false;
        const MAX_LOGS = 5000;
        let promptListLoaded = false;
        let promptLoadedId = null;
        let promptDirty = false;
        let promptListPromise = null;
        let mainTab = 'logs';
        let promptFiles = [];
        let sdkOutput = null;
        let sdkShowTimeline = false;

        // SDK output functions
        async function loadSdkOutput() {
            try {
                const response = await fetch('/api/sdk-output', { cache: 'no-store' });
                if (!response.ok) {
                    if (response.status === 404) {
                        sdkOutput = null;
                        renderSdkOutput();
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                if (data.ok && data.output) {
                    sdkOutput = data.output;
                    renderSdkOutput();
                }
            } catch (e) {
                console.error('Failed to load SDK output:', e);
            }
        }

        function renderSdkOutput() {
            const sessionEl = document.getElementById('sdkSessionId');
            const msgCountEl = document.getElementById('sdkMessageCount');
            const toolCountEl = document.getElementById('sdkToolCount');
            const durationEl = document.getElementById('sdkDuration');
            const statusEl = document.getElementById('sdkStatus');
            const convEl = document.getElementById('sdkConversation');
            const timelineEl = document.getElementById('sdkTimeline');

            if (!sdkOutput) {
                sessionEl.textContent = '-';
                msgCountEl.textContent = '0';
                toolCountEl.textContent = '0';
                durationEl.textContent = '-';
                statusEl.textContent = '-';
                statusEl.className = 'sdk-status-pending';
                convEl.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128172;</div>
                        <div>No SDK output available</div>
                        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Run with --runner sdk to see structured output</div>
                    </div>
                `;
                timelineEl.innerHTML = '';
                return;
            }

            // Update stats
            sessionEl.textContent = sdkOutput.session_id ? sdkOutput.session_id.substring(0, 12) + '...' : '-';
            msgCountEl.textContent = String(sdkOutput.stats?.message_count || sdkOutput.messages?.length || 0);
            toolCountEl.textContent = String(sdkOutput.stats?.tool_call_count || sdkOutput.tool_calls?.length || 0);

            const duration = sdkOutput.stats?.duration_seconds;
            durationEl.textContent = duration ? `${duration.toFixed(1)}s` : '-';

            if (sdkOutput.success) {
                statusEl.textContent = 'Success';
                statusEl.className = 'sdk-status-success';
            } else if (sdkOutput.error) {
                statusEl.textContent = 'Error';
                statusEl.className = 'sdk-status-error';
            } else {
                statusEl.textContent = 'Running';
                statusEl.className = 'sdk-status-pending';
            }

            // Render conversation view
            if (sdkShowTimeline) {
                convEl.style.display = 'none';
                timelineEl.style.display = 'block';
                renderSdkTimeline();
            } else {
                convEl.style.display = 'block';
                timelineEl.style.display = 'none';
                renderSdkConversation();
            }
        }

        function renderSdkConversation() {
            const convEl = document.getElementById('sdkConversation');
            if (!sdkOutput || !sdkOutput.messages || sdkOutput.messages.length === 0) {
                convEl.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128172;</div>
                        <div>No messages</div>
                    </div>
                `;
                return;
            }

            const html = sdkOutput.messages.map(msg => {
                const type = msg.type || 'unknown';
                const timestamp = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '';
                let contentHtml = '';

                if (msg.content) {
                    contentHtml = `<div class="sdk-message-content">${escapeHtml(truncateText(msg.content, 1000))}</div>`;
                }

                let toolHtml = '';
                if (msg.tool_use) {
                    const inputStr = JSON.stringify(msg.tool_use.input || {}, null, 2);
                    toolHtml = `
                        <div class="sdk-tool-use">
                            <span class="sdk-tool-name">${escapeHtml(msg.tool_use.name)}</span>
                            <div class="sdk-tool-input">${escapeHtml(truncateText(inputStr, 300))}</div>
                        </div>
                    `;
                }

                return `
                    <div class="sdk-message ${type}">
                        <div class="sdk-message-header">
                            <span class="sdk-message-type">${type}${msg.subtype ? ` (${msg.subtype})` : ''}</span>
                            <span>${timestamp}</span>
                        </div>
                        ${contentHtml}
                        ${toolHtml}
                    </div>
                `;
            }).join('');

            convEl.innerHTML = html;
        }

        function renderSdkTimeline() {
            const timelineEl = document.getElementById('sdkTimeline');
            if (!sdkOutput || !sdkOutput.tool_calls || sdkOutput.tool_calls.length === 0) {
                timelineEl.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#9202;</div>
                        <div>No tool calls</div>
                    </div>
                `;
                return;
            }

            // Find max duration for scaling
            const maxDuration = Math.max(...sdkOutput.tool_calls.map(t => t.duration_ms || 0), 1);

            const html = sdkOutput.tool_calls.map(call => {
                const duration = call.duration_ms || 0;
                const percent = Math.min(100, (duration / maxDuration) * 100);
                const durationStr = duration >= 1000 ? `${(duration / 1000).toFixed(1)}s` : `${duration}ms`;

                return `
                    <div class="sdk-timeline-item">
                        <div class="sdk-timeline-name">${escapeHtml(call.name)}</div>
                        <div class="sdk-timeline-bar">
                            <div class="sdk-timeline-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="sdk-timeline-duration">${durationStr}</div>
                    </div>
                `;
            }).join('');

            timelineEl.innerHTML = html;
        }

        function truncateText(text, maxLen) {
            if (!text) return '';
            if (text.length <= maxLen) return text;
            return text.substring(0, maxLen) + '...';
        }

        async function resyncLogs() {
            try {
                const response = await fetch('/api/logs', { cache: 'no-store' });
                if (!response.ok) return;
                const data = await response.json();
                if (data && Array.isArray(data.logs)) {
                    allLogs = data.logs.slice(-MAX_LOGS);
                    scheduleRender();
                }
            } catch (e) {
                console.warn('Failed to resync logs:', e);
            }
        }

        function scheduleRender() {
            if (renderScheduled) return;
            renderScheduled = true;
            requestAnimationFrame(() => {
                renderScheduled = false;
                renderLogs();
            });
        }
        
        // Request notification permission on load
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission().then(perm => {
                notificationsEnabled = perm === 'granted';
            });
        } else if ('Notification' in window) {
            notificationsEnabled = Notification.permission === 'granted';
        }
        
        // Audio notification (simple beep using Web Audio API)
        function playNotificationSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                // Pleasant notification sound
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.5);
                
                // Second tone for completion
                setTimeout(() => {
                    const osc2 = audioCtx.createOscillator();
                    const gain2 = audioCtx.createGain();
                    osc2.connect(gain2);
                    gain2.connect(audioCtx.destination);
                    osc2.frequency.value = 1000;
                    osc2.type = 'sine';
                    gain2.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc2.start(audioCtx.currentTime);
                    osc2.stop(audioCtx.currentTime + 0.5);
                }, 200);
            } catch (e) {
                console.log('Audio notification not available');
            }
        }
        
        function showNotification(title, body) {
            // Play sound
            playNotificationSound();
            
            // Browser notification
            if (notificationsEnabled) {
                new Notification(title, {
                    body: body,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">R</text></svg>'
                });
            }
        }
        
        // DOM elements
        const logContent = document.getElementById('logContent');
        const logCount = document.getElementById('logCount');
        const searchInput = document.getElementById('searchInput');
        const logsSearchContainer = document.getElementById('logsSearchContainer');
        const logsBody = document.getElementById('logsBody');
        const promptsBody = document.getElementById('promptsBody');
        const sdkBody = document.getElementById('sdkBody');
        const tabLogs = document.getElementById('tabLogs');
        const tabSdk = document.getElementById('tabSdk');
        const tabPrompts = document.getElementById('tabPrompts');
        const btnSdkRefresh = document.getElementById('btnSdkRefresh');
        const btnSdkTimeline = document.getElementById('btnSdkTimeline');
        const btnAutoScroll = document.getElementById('btnAutoScroll');
        const btnClear = document.getElementById('btnClear');
        const btnHideDiffs = document.getElementById('btnHideDiffs');
        const logControls = document.getElementById('logControls');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const statusBadge = document.getElementById('statusBadge');
        const iterationBadge = document.getElementById('iterationBadge');
        const iterationNumber = document.getElementById('iterationNumber');
        const iterationMax = document.getElementById('iterationMax');
        const phaseTimeline = document.getElementById('phaseTimeline');
        const infoGrid = document.getElementById('infoGrid');
        const statusChecks = document.getElementById('statusChecks');
        const checksCard = document.getElementById('checksCard');
        const runRunner = document.getElementById('runRunner');
        const runMaxIterations = document.getElementById('runMaxIterations');
        const configReviewPasses = document.getElementById('configReviewPasses');
        const configAutoSkipTaskReviews = document.getElementById('configAutoSkipTaskReviews');
        const btnRun = document.getElementById('btnRun');
        const btnStop = document.getElementById('btnStop');
        const runStatusText = document.getElementById('runStatusText');

        const gitBranch = document.getElementById('gitBranch');
        const btnGitUpdateMain = document.getElementById('btnGitUpdateMain');
        const gitStatusText = document.getElementById('gitStatusText');

        let runIsRunning = false;

        const sidebarTabSetup = document.getElementById('sidebarTabSetup');
        const sidebarTabMonitor = document.getElementById('sidebarTabMonitor');
        const sidebarSetupSection = document.getElementById('sidebarSetupSection');
        const sidebarMonitorSection = document.getElementById('sidebarMonitorSection');

        const promptSelect = document.getElementById('promptSelect');
        const promptTabs = document.getElementById('promptTabs');
        const promptEditor = document.getElementById('promptEditor');
        const btnPromptReload = document.getElementById('btnPromptReload');
        const btnPromptSave = document.getElementById('btnPromptSave');
        const promptStatusText = document.getElementById('promptStatusText');

        const initIssueNumber = document.getElementById('initIssueNumber');
        const initDesignDoc = document.getElementById('initDesignDoc');
        const initRepo = document.getElementById('initRepo');
        const initBranch = document.getElementById('initBranch');
        const initForce = document.getElementById('initForce');
        const btnInitIssue = document.getElementById('btnInitIssue');
        const initStatusText = document.getElementById('initStatusText');
        
        function updateHideDiffsButton() {
            if (!btnHideDiffs) return;
            btnHideDiffs.classList.toggle('active', hideDiffs);
            btnHideDiffs.textContent = hideDiffs ? 'Show diffs' : 'Hide diffs';
        }

        try {
            hideDiffs = localStorage.getItem('jeeves_viewer_hide_diffs') === '1';
        } catch (e) {
            // ignore
        }
        updateHideDiffsButton();

        // Phase definitions
        const phases = [
            { id: 'design', name: 'Design', desc: 'Create design document' },
            { id: 'task-implement', name: 'Task Implement', desc: 'Implement current task' },
            { id: 'task-spec-review', name: 'Task Spec Review', desc: 'Check task spec compliance' },
            { id: 'task-quality-review', name: 'Task Quality Review', desc: 'Review task code quality' },
            { id: 'implement', name: 'Implement', desc: 'Build and create PR' },
            { id: 'questions', name: 'Questions', desc: 'Resolve open questions' },
            { id: 'review', name: 'Review', desc: 'Address PR feedback' },
            { id: 'ci', name: 'CI', desc: 'Verify GitHub CI is green' },
            { id: 'coverage', name: 'Coverage', desc: 'Add test coverage' },
            { id: 'sonar', name: 'Sonar', desc: 'Fix code quality' },
            { id: 'complete', name: 'Complete', desc: 'All checks passed' }
        ];
        
        const phaseOrder = ['design', 'task-implement', 'task-spec-review', 'task-quality-review', 'implement', 'questions', 'review', 'ci', 'coverage-fix', 'coverage', 'sonar', 'complete'];
        
        function getPhaseIndex(phase) {
            // Normalize coverage-fix to coverage
            if (phase === 'coverage-fix') phase = 'coverage';
            return phaseOrder.indexOf(phase);
        }

        let sidebarTab = 'setup';

        function setSidebarTab(tab) {
            sidebarTab = tab === 'monitor' ? 'monitor' : 'setup';
            if (sidebarTabSetup) sidebarTabSetup.classList.toggle('active', sidebarTab === 'setup');
            if (sidebarTabMonitor) sidebarTabMonitor.classList.toggle('active', sidebarTab === 'monitor');
            if (sidebarSetupSection) sidebarSetupSection.style.display = sidebarTab === 'setup' ? 'block' : 'none';
            if (sidebarMonitorSection) sidebarMonitorSection.style.display = sidebarTab === 'monitor' ? 'block' : 'none';

            try {
                localStorage.setItem('jeeves_viewer_sidebar_tab', sidebarTab);
            } catch (e) {
                // ignore
            }
        }

        if (sidebarTabSetup) sidebarTabSetup.addEventListener('click', () => setSidebarTab('setup'));
        if (sidebarTabMonitor) sidebarTabMonitor.addEventListener('click', () => setSidebarTab('monitor'));

        try {
            const savedSidebar = localStorage.getItem('jeeves_viewer_sidebar_tab');
            setSidebarTab(savedSidebar || 'setup');
        } catch (e) {
            setSidebarTab('setup');
        }

        function setMainTab(tab) {
            if (tab === 'prompts') mainTab = 'prompts';
            else if (tab === 'sdk') mainTab = 'sdk';
            else mainTab = 'logs';

            if (tabLogs) tabLogs.classList.toggle('active', mainTab === 'logs');
            if (tabSdk) tabSdk.classList.toggle('active', mainTab === 'sdk');
            if (tabPrompts) tabPrompts.classList.toggle('active', mainTab === 'prompts');

            if (logsSearchContainer) logsSearchContainer.style.display = mainTab === 'logs' ? 'block' : 'none';
            if (logsBody) logsBody.style.display = mainTab === 'logs' ? 'flex' : 'none';
            if (logControls) logControls.style.display = mainTab === 'logs' ? 'flex' : 'none';
            if (logCount) logCount.style.display = mainTab === 'logs' ? 'inline-block' : 'none';

            if (promptsBody) promptsBody.style.display = mainTab === 'prompts' ? 'flex' : 'none';
            if (mainTab === 'prompts' && promptEditor) promptEditor.focus();

            if (sdkBody) sdkBody.style.display = mainTab === 'sdk' ? 'flex' : 'none';
            if (mainTab === 'sdk') loadSdkOutput();

            try {
                localStorage.setItem('jeeves_viewer_main_tab', mainTab);
            } catch (e) {
                // ignore
            }
        }

        if (tabLogs) tabLogs.addEventListener('click', () => setMainTab('logs'));
        if (tabSdk) tabSdk.addEventListener('click', () => setMainTab('sdk'));
        if (tabPrompts) tabPrompts.addEventListener('click', () => setMainTab('prompts'));

        if (btnSdkRefresh) btnSdkRefresh.addEventListener('click', () => loadSdkOutput());
        if (btnSdkTimeline) btnSdkTimeline.addEventListener('click', () => {
            sdkShowTimeline = !sdkShowTimeline;
            btnSdkTimeline.classList.toggle('active', sdkShowTimeline);
            btnSdkTimeline.textContent = sdkShowTimeline ? 'Conversation' : 'Timeline';
            renderSdkOutput();
        });

        try {
            const savedTab = localStorage.getItem('jeeves_viewer_main_tab');
            setMainTab(savedTab || 'logs');
        } catch (e) {
            setMainTab('logs');
        }
        
        // Connection handling
        function connect() {
            if (eventSource) {
                eventSource.close();
            }
            
            eventSource = new EventSource('/api/stream');
            
            eventSource.onopen = () => {
                updateConnectionStatus(true);
                if (reconnectAttempts > 0) {
                    resyncLogs();
                }
                reconnectAttempts = 0;
            };
            
            eventSource.addEventListener('state', (event) => {
                try {
                    const state = JSON.parse(event.data);
                    updateState(state);
                } catch (e) {
                    console.error('Failed to parse state:', e);
                }
            });
            
            eventSource.addEventListener('logs', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.lines && data.lines.length > 0) {
                        appendLogs(data.lines);
                    }
                } catch (e) {
                    console.error('Failed to parse logs:', e);
                }
            });
            
            eventSource.addEventListener('heartbeat', () => {
                // Keep-alive received
            });
            
            eventSource.onerror = () => {
                updateConnectionStatus(false);
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                setTimeout(connect, delay);
            };
        }
        
        function updateConnectionStatus(connected) {
            if (connected) {
                connectionDot.classList.add('connected');
                connectionText.textContent = 'Live';
            } else {
                connectionDot.classList.remove('connected');
                connectionText.textContent = 'Reconnecting...';
            }
        }
        
        function updateState(state) {
            currentState = state;
            
            const mode = state.mode;
            const status = state.status || {};
            const config = state.config || {};
            const run = state.run || {};
            
            // Update iteration
            if (state.iteration) {
                iterationBadge.style.display = 'flex';
                iterationNumber.textContent = state.iteration.current;
                iterationMax.textContent = state.iteration.max;
            } else {
                iterationBadge.style.display = 'none';
            }
            
            // Update status badge
            if (run.running) {
                setStatusBadge('running', 'Running');
            } else if (mode === 'unknown') {
                setStatusBadge('idle', 'Idle');
            } else if (status.phase === 'complete') {
                setStatusBadge('complete', 'Complete');
                // Notify on completion (only once)
                if (lastPhase && lastPhase !== 'complete') {
                    showNotification('Jeeves Complete!', 'All workflow phases have finished successfully.');
                }
            } else {
                setStatusBadge('idle', 'Ready');
            }
            
            // Track phase changes for notifications
            lastPhase = status.phase;
            
            // Update phase timeline
            if (mode === 'issue') {
                updatePhaseTimeline(status.phase || 'design', status.current_task, status.tasks_total, status.tasks_done);
                checksCard.style.display = 'block';
                updateStatusChecks(status);
            } else if (mode === 'prd') {
                updatePRDProgress(status);
                checksCard.style.display = 'none';
            } else {
                phaseTimeline.innerHTML = '<div class="empty-state"><div class="empty-title">No active workflow</div></div>';
                checksCard.style.display = 'none';
            }
            
            // Update info grid
            updateInfoGrid(mode, status, config);

            // Prompt editor bootstrap (pick the currently-active prompt once).
            if (promptSelect || promptTabs) {
                const activePrompt = promptIdForState(state);
                const chooseAndLoad = (promptId) => {
                    if (promptLoadedId || promptDirty) return;
                    let id = promptId;
                    if (promptSelect) {
                        const hasOption = Array.from(promptSelect.options).some(o => o.value === id);
                        if (!hasOption) id = promptSelect.options[0] ? promptSelect.options[0].value : '';
                    } else if (Array.isArray(promptFiles) && promptFiles.length > 0) {
                        const has = promptFiles.some(p => p.id === id);
                        if (!has) id = promptFiles[0].id;
                    }
                    if (id) setCurrentPromptId(id, { confirmDiscard: false });
                };

                if (!promptListLoaded) loadPromptList().then(() => chooseAndLoad(activePrompt));
                else chooseAndLoad(activePrompt);
            }

            // Prefill config from current state (only when at defaults).
            const issueConfig = config.config || {};
            if (configReviewPasses && configReviewPasses.value === '3' && issueConfig.reviewCleanPassesRequired !== undefined) {
                configReviewPasses.value = String(issueConfig.reviewCleanPassesRequired);
            }
            if (configAutoSkipTaskReviews && !configAutoSkipTaskReviews.checked && issueConfig.autoSkipTaskReviews === true) {
                configAutoSkipTaskReviews.checked = true;
            }

            // Prefill init form from current state (only when empty).
            if (initIssueNumber && !initIssueNumber.value && status.issue_number) {
                initIssueNumber.value = String(status.issue_number);
            }
            if (initDesignDoc && !initDesignDoc.value && status.design_doc) {
                initDesignDoc.value = String(status.design_doc);
            }
            if (initBranch && !initBranch.value && status.branch_name) {
                initBranch.value = String(status.branch_name);
            }
            if (initRepo && !initRepo.value) {
                const repo = (config.issue && config.issue.repo) ? config.issue.repo : '';
                if (repo) initRepo.value = String(repo);
            }

            // Update logs from initial state
            if (state.recent_logs && state.recent_logs.length > 0 && allLogs.length === 0) {
                appendLogs(state.recent_logs);
            }

            updateRunControls(run);

            // Auto-switch sidebar to Monitor while running (reduces clutter).
            if (run.running && sidebarTab !== 'monitor') {
                setSidebarTab('monitor');
            }
        }

        function updateRunControls(run) {
            if (!runStatusText) return;
            const running = !!run.running;
            runIsRunning = running;

            if (btnRun) btnRun.disabled = running;
            if (btnStop) btnStop.disabled = !running;
            if (btnGitUpdateMain) btnGitUpdateMain.disabled = running;

            if (running) {
                runStatusText.textContent = `Running (pid ${run.pid || '?'})\nStarted: ${run.started_at || ''}`;
            } else if (run.returncode !== null && run.returncode !== undefined) {
                runStatusText.textContent = `Not running\nLast exit code: ${run.returncode}`;
            } else {
                runStatusText.textContent = 'Not running';
            }
        }
        
        function setStatusBadge(type, text) {
            statusBadge.className = 'status-badge ' + type;
            statusBadge.textContent = text;
        }

        async function apiPost(path, body) {
            const response = await fetch(path, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body || {})
            });
            const data = await response.json().catch(() => null);
            return { response, data };
        }

        async function updateIssueStatus(updates) {
            const { response, data } = await apiPost('/api/issue/status', { updates: updates || {} });
            if (!response.ok || !data || !data.ok) {
                const msg = (data && data.error) ? data.error : `Failed to update status (HTTP ${response.status})`;
                throw new Error(msg);
            }
            return data;
        }

        if (btnGitUpdateMain) {
            btnGitUpdateMain.addEventListener('click', async () => {
                const branch = gitBranch ? (gitBranch.value || '').trim() : 'main';
                if (!branch) {
                    alert('Branch is required.');
                    return;
                }

                if (!confirm(`Checkout '${branch}' and update it from origin?`)) return;

                btnGitUpdateMain.disabled = true;
                if (gitStatusText) gitStatusText.textContent = `Updating ${branch}...`;
                try {
                    const { response, data } = await apiPost('/api/git/update-main', { branch });
                    if (!response.ok || !data || !data.ok) {
                        const msg = (data && data.error) ? data.error : `Git update failed (HTTP ${response.status})`;
                        if (gitStatusText) gitStatusText.textContent = msg;
                        return;
                    }
                    const shortSha = (data.commit || '').slice(0, 7);
                    if (gitStatusText) gitStatusText.textContent = `Now on ${data.branch || branch}${shortSha ? ` @ ${shortSha}` : ''}`;
                } catch (e) {
                    if (gitStatusText) gitStatusText.textContent = 'Git update failed: ' + e;
                } finally {
                    btnGitUpdateMain.disabled = runIsRunning;
                }
            });
        }

        function promptIdForState(state) {
            if (!state) return null;
            if (state.mode === 'prd') return 'prompt.md';
            if (state.mode !== 'issue') return null;
            const phase = (state.status && state.status.phase) ? state.status.phase : 'implement';
            const map = {
                'design': 'design.md',
                'task-implement': 'task/implement.md',
                'task-spec-review': 'task/spec-review.md',
                'task-quality-review': 'task/quality-review.md',
                'implement': 'implement.md',
                'review': 'review.md',
                'questions': 'questions.md',
                'ci': 'ci.md',
                'coverage': 'coverage.md',
                'coverage-fix': 'coverage-fix.md',
                'sonar': 'sonar.md',
                'complete': 'sonar.md'
            };
            return map[phase] || 'implement.md';
        }

        function promptTabLabel(promptId) {
            if (!promptId) return '';
            if (promptId === 'prompt.md') return 'prd';
            let label = promptId;
            // Handle task/ subdirectory prompts
            if (label.startsWith('task/')) label = 'task ' + label.slice(5);
            if (label.endsWith('.md')) label = label.slice(0, -3);
            return label.replace(/\//g, ' / ');
        }

        function updatePromptTabsActive() {
            if (!promptTabs) return;
            const buttons = Array.from(promptTabs.querySelectorAll('[data-prompt-id]'));
            for (const btn of buttons) {
                const id = btn.getAttribute('data-prompt-id');
                btn.classList.toggle('active', !!promptLoadedId && id === promptLoadedId);
            }
        }

        function renderPromptTabs(prompts) {
            if (!promptTabs) return;
            promptTabs.innerHTML = '';
            for (const p of prompts) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'prompt-tab';
                btn.textContent = promptTabLabel(p.id);
                btn.setAttribute('data-prompt-id', p.id);
                btn.addEventListener('click', async () => {
                    await setCurrentPromptId(p.id, { confirmDiscard: true });
                });
                promptTabs.appendChild(btn);
            }
            updatePromptTabsActive();
        }

        async function setCurrentPromptId(promptId, { confirmDiscard = true } = {}) {
            if (!promptId) return;

            if (confirmDiscard && promptDirty && promptLoadedId && promptId !== promptLoadedId) {
                if (!confirm('Discard unsaved changes?')) {
                    if (promptSelect) promptSelect.value = promptLoadedId;
                    updatePromptTabsActive();
                    return;
                }
            }

            if (promptSelect) promptSelect.value = promptId;
            await loadPromptContent(promptId);
        }

        async function reloadPrompt() {
            const id = promptLoadedId || (promptSelect ? promptSelect.value : '');
            if (!id) return;
            if (promptDirty) {
                if (!confirm('Discard unsaved changes and reload?')) return;
            }
            await loadPromptContent(id);
        }

        async function loadPromptList() {
            if (!promptSelect && !promptTabs) return;
            if (promptListLoaded) return;
            if (promptListPromise) return promptListPromise;

            promptListPromise = (async () => {
                const response = await fetch('/api/prompts', { cache: 'no-store' });
                const data = await response.json().catch(() => null);
                if (!response.ok || !data || !data.ok) {
                    throw new Error('Failed to load prompt list');
                }

                const prompts = Array.isArray(data.prompts) ? data.prompts : [];
                promptFiles = prompts;
                if (promptSelect) {
                    const previous = promptSelect.value || promptLoadedId;
                    promptSelect.innerHTML = '';
                    for (const p of prompts) {
                        const opt = document.createElement('option');
                        opt.value = p.id;
                        opt.textContent = p.name;
                        promptSelect.appendChild(opt);
                    }
                    if (previous) promptSelect.value = previous;
                }
                renderPromptTabs(prompts);
                promptListLoaded = true;
            })()
                .catch((e) => {
                    promptListPromise = null;
                    if (promptStatusText) promptStatusText.textContent = String(e);
                });

            return promptListPromise;
        }

        async function loadPromptContent(promptId) {
            if (!promptEditor || !promptId) return;
            const response = await fetch('/api/prompts/' + encodeURIComponent(promptId), { cache: 'no-store' });
            const data = await response.json().catch(() => null);
            if (!response.ok || !data || !data.ok) {
                const msg = (data && data.error) ? data.error : `Failed to load prompt (HTTP ${response.status})`;
                if (promptStatusText) promptStatusText.textContent = msg;
                return;
            }
            promptLoadedId = promptId;
            if (promptSelect) promptSelect.value = promptId;
            promptEditor.value = (data.prompt && typeof data.prompt.content === 'string') ? data.prompt.content : '';
            promptDirty = false;
            if (promptStatusText) promptStatusText.textContent = `Loaded ${promptId}`;
            updatePromptTabsActive();
        }

        async function savePromptContent() {
            if (!promptLoadedId || !promptEditor) return;
            if (btnPromptSave) btnPromptSave.disabled = true;
            try {
                const { response, data } = await apiPost('/api/prompts/' + encodeURIComponent(promptLoadedId), { content: promptEditor.value });
                if (!response.ok || !data || !data.ok) {
                    const msg = (data && data.error) ? data.error : `Failed to save (HTTP ${response.status})`;
                    if (promptStatusText) promptStatusText.textContent = msg;
                    return;
                }
                promptDirty = false;
                if (promptStatusText) promptStatusText.textContent = `Saved ${promptLoadedId}`;
            } finally {
                if (btnPromptSave) btnPromptSave.disabled = false;
            }
        }

        async function initIssue() {
            if (btnInitIssue) btnInitIssue.disabled = true;
            if (initStatusText) initStatusText.textContent = 'Running init-issue.sh...';
            try {
                const { response, data } = await apiPost('/api/init/issue', {
                    issue: initIssueNumber ? initIssueNumber.value : '',
                    design_doc: initDesignDoc ? initDesignDoc.value : '',
                    repo: initRepo ? initRepo.value : '',
                    branch: initBranch ? initBranch.value : '',
                    force: initForce ? !!initForce.checked : false
                });

                if (!response.ok || !data || !data.ok) {
                    const msg = (data && data.output) ? data.output : ((data && data.error) ? data.error : `Init failed (HTTP ${response.status})`);
                    if (initStatusText) initStatusText.textContent = msg;
                    return;
                }

                if (initStatusText) initStatusText.textContent = (data.output || 'Init complete.');
            } catch (e) {
                if (initStatusText) initStatusText.textContent = 'Init failed: ' + e;
            } finally {
                if (btnInitIssue) btnInitIssue.disabled = false;
            }
        }

        if (btnRun) {
            btnRun.addEventListener('click', async () => {
                btnRun.disabled = true;
                try {
                    const runner = runRunner ? runRunner.value : 'auto';
                    const maxIterations = runMaxIterations ? parseInt(runMaxIterations.value || '10', 10) : 10;
                    const reviewPasses = configReviewPasses ? parseInt(configReviewPasses.value || '3', 10) : 3;
                    const autoSkipTaskReviews = configAutoSkipTaskReviews ? configAutoSkipTaskReviews.checked : false;

                    const envOverrides = {};
                    if (Number.isFinite(reviewPasses) && reviewPasses >= 1) {
                        envOverrides['JEEVES_REVIEW_CLEAN_PASSES_REQUIRED'] = String(reviewPasses);
                    }
                    if (autoSkipTaskReviews) {
                        envOverrides['JEEVES_AUTO_SKIP_TASK_REVIEWS'] = 'true';
                    }

                    const { response, data } = await apiPost('/api/run', {
                        runner: runner,
                        max_iterations: Number.isFinite(maxIterations) ? maxIterations : 10,
                        output_mode: 'stream',
                        env: envOverrides
                    });

                    if (!response.ok) {
                        const msg = (data && data.error) ? data.error : `Failed to start (HTTP ${response.status})`;
                        alert(msg);
                        return;
                    }
                } catch (e) {
                    alert('Failed to start: ' + e);
                } finally {
                    btnRun.disabled = false;
                }
            });
        }

        if (btnStop) {
            btnStop.addEventListener('click', async () => {
                btnStop.disabled = true;
                try {
                    const { response, data } = await apiPost('/api/run/stop', {});
                    if (!response.ok) {
                        const msg = (data && data.error) ? data.error : `Failed to stop (HTTP ${response.status})`;
                        alert(msg);
                        return;
                    }
                } catch (e) {
                    alert('Failed to stop: ' + e);
                } finally {
                    btnStop.disabled = false;
                }
            });
        }

        if (promptSelect) {
            promptSelect.addEventListener('change', async () => {
                const id = promptSelect.value;
                await setCurrentPromptId(id, { confirmDiscard: true });
            });
        }

        if (promptEditor) {
            promptEditor.addEventListener('input', () => {
                promptDirty = true;
                if (promptStatusText && promptLoadedId) {
                    promptStatusText.textContent = `Editing ${promptLoadedId} (unsaved)`;
                }
            });
        }

        if (btnPromptReload) {
            btnPromptReload.addEventListener('click', async () => {
                await reloadPrompt();
            });
        }

        if (btnPromptSave) {
            btnPromptSave.addEventListener('click', async () => {
                await savePromptContent();
            });
        }

        if (btnInitIssue) {
            btnInitIssue.addEventListener('click', async () => {
                await initIssue();
            });
        }
        
        function updatePhaseTimeline(currentPhase, currentTask, tasksTotal, tasksDone) {
            const currentIndex = getPhaseIndex(currentPhase);

            // Build task description for task phases
            const isTaskPhase = (phase) => ['task-implement', 'task-spec-review', 'task-quality-review'].includes(phase);
            const getTaskDesc = (phase) => {
                if (!isTaskPhase(phase) || !currentTask) return null;
                const progress = tasksTotal > 0 ? ` (${tasksDone}/${tasksTotal} done)` : '';
                const title = currentTask.title || currentTask.id || 'Unknown';
                return `Task ${currentTask.index}: ${escapeHtml(title)}${progress}`;
            };

            phaseTimeline.innerHTML = phases.map((phase, index) => {
                const phaseIdx = getPhaseIndex(phase.id);
                let stateClass = '';
                let icon = '';

                if (phaseIdx < currentIndex || currentPhase === 'complete') {
                    stateClass = 'complete';
                    icon = '&#10003;';
                } else if (phase.id === currentPhase || (currentPhase === 'coverage-fix' && phase.id === 'coverage')) {
                    stateClass = 'active';
                    icon = '&#9679;';
                }

                // Determine description
                let desc = phase.desc;
                if (currentPhase === 'coverage-fix' && phase.id === 'coverage') {
                    desc = 'Fixing test failures';
                } else if (phase.id === currentPhase && isTaskPhase(phase.id)) {
                    const taskDesc = getTaskDesc(phase.id);
                    if (taskDesc) desc = taskDesc;
                }

                return `
                    <div class="phase-item ${stateClass}">
                        <div class="phase-dot">${icon}</div>
                        <div class="phase-content">
                            <div class="phase-name">${phase.name}</div>
                            <div class="phase-desc">${desc}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updatePRDProgress(status) {
            const total = status.total_stories || 0;
            const passing = status.passing_stories || 0;
            const percent = total > 0 ? Math.round((passing / total) * 100) : 0;
            
            phaseTimeline.innerHTML = `
                <div class="progress-section">
                    <div class="progress-header">
                        <span>Stories Progress</span>
                        <span>${passing} / ${total} (${percent}%)</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${percent}%"></div>
                    </div>
                </div>
                ${status.stories ? `
                    <div style="margin-top: 16px;">
                        ${status.stories.map(s => `
                            <div style="display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border-color);">
                                <span style="color: ${s.passes ? 'var(--accent-green)' : 'var(--text-muted)'};">${s.passes ? '&#10003;' : '&#9675;'}</span>
                                <span style="font-size: 13px;">${escapeHtml(s.title)}</span>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
        }
        
        function updateInfoGrid(mode, status, config) {
            let items = [];
            
            items.push({ label: 'Mode', value: mode.charAt(0).toUpperCase() + mode.slice(1) });
            
            if (mode === 'issue') {
                if (status.issue_number) {
                    const url = status.issue_url || `#${status.issue_number}`;
                    items.push({ 
                        label: 'Issue', 
                        value: `<a href="${escapeHtml(status.issue_url || '#')}" target="_blank">#${status.issue_number}</a>`
                    });
                }
                
                if (status.pr_number) {
                    items.push({ 
                        label: 'Pull Request', 
                        value: `<a href="${escapeHtml(status.pr_url || '#')}" target="_blank">#${status.pr_number}</a>`
                    });
                }
                
                if (status.branch_name) {
                    items.push({ label: 'Branch', value: escapeHtml(status.branch_name) });
                }
                
                if (status.design_doc) {
                    items.push({ label: 'Design Doc', value: escapeHtml(status.design_doc.split('/').pop()) });
                }
                
                items.push({ label: 'Phase', value: formatPhase(status.phase) });
            } else if (mode === 'prd') {
                items.push({ label: 'Stories', value: `${status.passing_stories || 0} / ${status.total_stories || 0}` });
            }
            
            infoGrid.innerHTML = items.map(item => `
                <div class="info-row">
                    <span class="info-label">${item.label}</span>
                    <span class="info-value">${item.value}</span>
                </div>
            `).join('');
        }
        
        function formatPhase(phase) {
            const names = {
                'design': 'Design',
                'task-implement': 'Task Implement',
                'task-spec-review': 'Task Spec Review',
                'task-quality-review': 'Task Quality Review',
                'implement': 'Implement',
                'review': 'Review',
                'ci': 'CI',
                'coverage': 'Coverage',
                'coverage-fix': 'Fix Coverage',
                'sonar': 'Sonar',
                'complete': 'Complete'
            };
            return names[phase] || phase;
        }
        
        function updateStatusChecks(status) {
            const checks = [
                { label: 'Implemented', value: status.implemented, toggleKey: 'implemented' },
                { label: 'PR Created', value: status.pr_created },
                { label: 'PR Ready', value: status.pr_description_ready },
                { label: 'Review Clean', value: status.review_clean, toggleKey: 'reviewClean' },
                { label: 'CI', value: status.ci_clean, toggleKey: 'ciClean' },
                { label: 'Coverage', value: status.coverage_clean, toggleKey: 'coverageClean' },
                { label: 'Sonar', value: status.sonar_clean, toggleKey: 'sonarClean' }
            ];
            
            statusChecks.innerHTML = checks.map(check => {
                const tag = check.toggleKey ? 'button' : 'div';
                const className = `status-check${check.toggleKey ? ' toggleable' : ''}`;
                const disabled = check.toggleKey && runIsRunning ? ' disabled' : '';
                const attrs = check.toggleKey
                    ? ` type="button" data-status-key="${check.toggleKey}" data-status-value="${check.value ? '1' : '0'}"${disabled} title="Click to toggle"`
                    : '';

                return `
                    <${tag} class="${className}"${attrs}>
                        <div class="check-icon ${check.value ? 'pass' : 'fail'}">
                            ${check.value ? '&#10003;' : ''}
                        </div>
                        <span>${check.label}</span>
                    </${tag}>
                `;
            }).join('');

            const toggleButtons = Array.from(statusChecks.querySelectorAll('button.status-check.toggleable'));
            for (const btn of toggleButtons) {
                btn.addEventListener('click', async () => {
                    const key = btn.getAttribute('data-status-key');
                    const current = btn.getAttribute('data-status-value') === '1';
                    const next = !current;

                    btn.disabled = true;
                    try {
                        await updateIssueStatus({ [key]: next });

                        btn.setAttribute('data-status-value', next ? '1' : '0');
                        const icon = btn.querySelector('.check-icon');
                        if (icon) {
                            icon.classList.toggle('pass', next);
                            icon.classList.toggle('fail', !next);
                            icon.innerHTML = next ? '&#10003;' : '';
                        }
                    } catch (e) {
                        alert((e && e.message) ? e.message : String(e));
                    } finally {
                        btn.disabled = runIsRunning;
                    }
                });
            }
        }
        
        // Log handling
        const diffState = { inDiff: false };

        function updateLogCount(count) {
            logCount.textContent = `${count} lines`;
        }

        function isDiffStartLine(line) {
            return line.startsWith('diff --git ') || line.startsWith('--- a/') || line.startsWith('+++ b/');
        }

        function isDiffMetaLine(line) {
            return (
                line.startsWith('diff --git ') ||
                line.startsWith('index ') ||
                line.startsWith('--- ') ||
                line.startsWith('+++ ') ||
                line.startsWith('@@ ') ||
                line.startsWith('new file mode ') ||
                line.startsWith('deleted file mode ') ||
                line.startsWith('similarity index ') ||
                line.startsWith('rename from ') ||
                line.startsWith('rename to ') ||
                line.startsWith('copy from ') ||
                line.startsWith('copy to ') ||
                line.startsWith('Binary files ') ||
                line.startsWith('\\ No newline at end of file')
            );
        }

        function isDiffContentLine(line) {
            return line.startsWith('+') || line.startsWith('-') || line.startsWith(' ') || line.startsWith('\\');
        }

        function getLogClassForLine(line) {
            if (line === '') {
                diffState.inDiff = false;
                return '';
            }

            if (isDiffStartLine(line)) {
                diffState.inDiff = true;
                if (line.startsWith('diff --git ')) return 'diff-header';
                return 'diff-file';
            }

            if (diffState.inDiff) {
                if (!(isDiffMetaLine(line) || isDiffContentLine(line))) {
                    diffState.inDiff = false;
                }
            }

            if (diffState.inDiff) {
                if (line.startsWith('@@ ')) return 'diff-hunk';
                if (line.startsWith('index ')) return 'diff-meta';
                if (line.startsWith('--- ') || line.startsWith('+++ ')) return 'diff-file';
                if (line.startsWith('+') && !line.startsWith('+++ ')) return 'diff-add';
                if (line.startsWith('-') && !line.startsWith('--- ')) return 'diff-del';
                if (line.startsWith(' ')) return 'diff-context';
                return 'diff-meta';
            }

            if (line === 'thinking' || line === 'exec') return 'section';
            if (/^file update:?$/i.test(line)) return 'section';
            if (line.startsWith('Plan update')) return 'section';
            if (line.startsWith('/bin/bash -lc ')) return 'command';
            if (/^apply_patch\(/.test(line)) return 'command';

            if (/\[ERROR\]|Error:|error:/i.test(line)) return 'error';
            if (/\[WARN\]|Warning:|warn:/i.test(line)) return 'warn';
            if (/\[INFO\]/i.test(line)) return 'info';
            if (/\[DEBUG\]/i.test(line)) return 'debug';
            if (/Jeeves Iteration \d+ of \d+/i.test(line)) return 'iteration';
            if (/completed|success|passed||/i.test(line)) return 'success';
            return '';
        }

        function ensureLogContainerReady() {
            if (logContent.dataset.empty === '1') {
                logContent.innerHTML = '';
                logContent.dataset.empty = '0';
            }
        }

        function appendLogLinesToDom(lines) {
            ensureLogContainerReady();

            const fragment = document.createDocumentFragment();
            for (const line of lines) {
                const className = getLogClassForLine(line);
                const div = document.createElement('div');
                div.className = `log-line ${className}`;
                div.textContent = line;
                fragment.appendChild(div);
            }
            logContent.appendChild(fragment);

            while (logContent.childElementCount > MAX_LOGS) {
                logContent.removeChild(logContent.firstElementChild);
            }

            updateLogCount(allLogs.length);
            if (autoScroll) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        }

        function appendLogs(lines) {
            const newLines = [];
            for (const line of lines) {
                if (allLogs.length >= MAX_LOGS) {
                    allLogs.shift();
                }
                allLogs.push(line);
                newLines.push(line);
            }

            if (!searchFilter && !hideDiffs) {
                appendLogLinesToDom(newLines);
                return;
            }

            scheduleRender();
        }

        function renderLogs() {
            const filterLower = searchFilter ? searchFilter.toLowerCase() : '';

            diffState.inDiff = false;
            const rendered = [];

            const hiddenDiff = {
                inDiff: false,
                placeholderEmitted: false,
                pendingFileUpdate: false,
            };

            function parseDiffHeaderPath(line) {
                const match = line.match(/^diff --git a\/(.+?) b\/(.+)$/);
                if (!match) return null;
                return match[1] || null;
            }

            function isDiffStartLine(line) {
                return line.startsWith('diff --git ') || line.startsWith('--- a/') || line.startsWith('+++ b/');
            }

            function isDiffContinuationLine(line) {
                return (
                    line === '' ||
                    line.startsWith('index ') ||
                    line.startsWith('@@ ') ||
                    line.startsWith('--- ') ||
                    line.startsWith('+++ ') ||
                    line.startsWith('+') ||
                    line.startsWith('-') ||
                    line.startsWith(' ') ||
                    line.startsWith('\\')
                );
            }

            function pushRendered(line, className) {
                if (filterLower && !line.toLowerCase().includes(filterLower)) return;
                rendered.push({ line, className });
            }

            for (const line of allLogs) {
                if (hideDiffs) {
                    if (/^file update:?$/i.test(line)) {
                        hiddenDiff.inDiff = true;
                        hiddenDiff.placeholderEmitted = false;
                        hiddenDiff.pendingFileUpdate = true;
                        continue;
                    }

                    if (hiddenDiff.inDiff) {
                        if (line.startsWith('diff --git ')) {
                            if (!hiddenDiff.placeholderEmitted) {
                                const path = parseDiffHeaderPath(line);
                                const placeholder = path ? `file update (diff hidden): ${path}` : 'file update (diff hidden)';
                                pushRendered(placeholder, 'section');
                                hiddenDiff.placeholderEmitted = true;
                            }
                            continue;
                        }

                        if (isDiffStartLine(line) || isDiffContinuationLine(line)) {
                            continue;
                        }

                        if (hiddenDiff.pendingFileUpdate && !hiddenDiff.placeholderEmitted) {
                            pushRendered('file update (diff hidden)', 'section');
                        }

                        hiddenDiff.inDiff = false;
                        hiddenDiff.placeholderEmitted = false;
                        hiddenDiff.pendingFileUpdate = false;
                        // fall through to handle the current line normally
                    }

                    if (isDiffStartLine(line)) {
                        const path = line.startsWith('diff --git ') ? parseDiffHeaderPath(line) : null;
                        const placeholder = path ? `diff (hidden): ${path}` : 'diff (hidden)';
                        pushRendered(placeholder, 'section');
                        hiddenDiff.inDiff = true;
                        hiddenDiff.placeholderEmitted = true;
                        hiddenDiff.pendingFileUpdate = false;
                        continue;
                    }
                }

                const className = getLogClassForLine(line);
                pushRendered(line, className);
            }

            if (hideDiffs && hiddenDiff.inDiff && hiddenDiff.pendingFileUpdate && !hiddenDiff.placeholderEmitted) {
                pushRendered('file update (diff hidden)', 'section');
            }

            updateLogCount(rendered.length);

            if (rendered.length === 0) {
                logContent.innerHTML = `
                    <div class="log-empty">
                        <div class="log-empty-icon">&#128196;</div>
                        <div>${searchFilter ? 'No matching logs' : 'Waiting for logs...'}</div>
                    </div>
                `;
                logContent.dataset.empty = '1';
                return;
            }

            logContent.dataset.empty = '0';
            const html = rendered
                .map(({ line, className }) => `<div class="log-line ${className}">${escapeHtml(line)}</div>`)
                .join('');

            logContent.innerHTML = html;

            if (autoScroll) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Event handlers
        btnAutoScroll.addEventListener('click', () => {
            autoScroll = !autoScroll;
            btnAutoScroll.classList.toggle('active', autoScroll);
            if (autoScroll) {
                logContent.scrollTop = logContent.scrollHeight;
            }
        });
        
        btnClear.addEventListener('click', () => {
            allLogs = [];
            renderLogs();
        });

        if (btnHideDiffs) btnHideDiffs.addEventListener('click', () => {
            hideDiffs = !hideDiffs;
            try {
                localStorage.setItem('jeeves_viewer_hide_diffs', hideDiffs ? '1' : '0');
            } catch (e) {
                // ignore
            }
            updateHideDiffsButton();
            scheduleRender();
        });
        
        searchInput.addEventListener('input', (e) => {
            searchFilter = e.target.value;
            renderLogs();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                if (mainTab === 'prompts' && promptEditor) {
                    promptEditor.focus();
                } else if (searchInput) {
                    searchInput.focus();
                }
            }
            if (e.key === 'Escape') {
                if (mainTab === 'logs' && searchInput) {
                    searchInput.value = '';
                    searchFilter = '';
                    renderLogs();
                    searchInput.blur();
                } else if (promptEditor) {
                    promptEditor.blur();
                }
            }
            if (e.key === 'End') {
                logContent.scrollTop = logContent.scrollHeight;
            }
        });
        
        // Detect manual scroll
        logContent.addEventListener('scroll', () => {
            const isAtBottom = logContent.scrollHeight - logContent.scrollTop - logContent.clientHeight < 50;
            if (!isAtBottom && autoScroll) {
                autoScroll = false;
                btnAutoScroll.classList.remove('active');
            }
        });
        
        // Start
        loadPromptList();
        connect();
    </script>
</body>
</html>
